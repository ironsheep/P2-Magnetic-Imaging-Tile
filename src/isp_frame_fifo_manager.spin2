'' isp_frame_fifo_manager.spin2 - Multi-FIFO Frame Pool Manager
'' Zero-copy architecture with three independent FIFOs sharing a common frame pool
''
'' FIFOs:
''   - FIFO_SENSOR: Sensor -> Frame Processor
''   - FIFO_HDMI:   Frame Processor -> HDMI Display Engine
''   - FIFO_OLED:   Frame Processor -> OLED Manager

CON
  ' FIFO IDs
  FIFO_SENSOR = 0
  FIFO_HDMI   = 1
  FIFO_OLED   = 2

  ' Frame configuration
  FRAME_SIZE  = 128         ' 64 sensors x 2 bytes each
  MAX_FRAMES  = 32          ' Total frames in pool
  FIFO_DEPTH  = 16          ' Max entries per FIFO

  ' Return codes
  SUCCESS     = 0
  ERR_FULL    = -1
  ERR_EMPTY   = -2
  ERR_INVALID = -3

DAT
  ' Singleton shared state - DAT section is shared across ALL OBJ instances
  ' This enables zero-copy frame sharing across all subsystems

  ' Frame pool - all frames live here
  framePool       byte  0[MAX_FRAMES * FRAME_SIZE]

  ' Free frame tracking
  freeList        long  0[MAX_FRAMES]
  freeHead        long  0
  freeTail        long  0
  freeCount       long  0

  ' FIFO structures - just hold pointers
  sensorFIFO      long  0[FIFO_DEPTH]
  sensorHead      long  0
  sensorTail      long  0
  sensorCount     long  0

  hdmiFIFO        long  0[FIFO_DEPTH]
  hdmiHead        long  0
  hdmiTail        long  0
  hdmiCount       long  0

  oledFIFO        long  0[FIFO_DEPTH]
  oledHead        long  0
  oledTail        long  0
  oledCount       long  0

  ' Lock for atomic operations
  lock            long  -1  ' -1 = uninitialized

PUB null()
  '' Not a top-level object

PUB start() : ok | i
  '' Initialize the frame pool and all FIFOs

  debug("FIFO: Acquiring lock...", 13, 10)
  lock := locknew()
  debug("FIFO: Lock acquired: ", sdec(lock), 13, 10)

  ' CRITICAL: Explicitly zero ALL FIFO arrays to prevent garbage pointer issues
  ' DAT section initialization may not reliably zero arrays
  debug("FIFO: Zeroing FIFO arrays...", 13, 10)
  longfill(@sensorFIFO, 0, FIFO_DEPTH)
  longfill(@hdmiFIFO, 0, FIFO_DEPTH)
  longfill(@oledFIFO, 0, FIFO_DEPTH)
  longfill(@freeList, 0, MAX_FRAMES)

  ' Initialize free list with all frames
  debug("FIFO: Initializing ", udec(MAX_FRAMES), " frames...", 13, 10)
  repeat i from 0 to MAX_FRAMES-1
    LONG[@freeList][i] := @framePool + (i * FRAME_SIZE)

  freeHead := 0
  freeTail := MAX_FRAMES - 1  ' CORRECT: Knuth's algorithm with count (full queue, next enqueue wraps to 0)
  freeCount := MAX_FRAMES

  debug("FIFO: freeCount = ", udec(freeCount), ", freeHead = ", udec(freeHead), ", freeTail = ", udec(freeTail), 13, 10)

  ' Initialize all FIFOs as empty
  sensorHead := sensorTail := sensorCount := 0
  hdmiHead := hdmiTail := hdmiCount := 0
  oledHead := oledTail := oledCount := 0

  debug("FIFO: Initialization complete", 13, 10)

  ' Debug: Print addresses of FIFO data structures for correlation with corruption values
  debug("FIFO ADDRESSES:", 13, 10)
  debug("  framePool:   ", uhex_long(@framePool), 13, 10)
  debug("  freeList:    ", uhex_long(@freeList), 13, 10)
  debug("  freeHead:    ", uhex_long(@freeHead), 13, 10)
  debug("  sensorFIFO:  ", uhex_long(@sensorFIFO), 13, 10)
  debug("  sensorHead:  ", uhex_long(@sensorHead), 13, 10)
  debug("  sensorTail:  ", uhex_long(@sensorTail), 13, 10)
  debug("  sensorCount: ", uhex_long(@sensorCount), 13, 10)
  debug("  hdmiFIFO:    ", uhex_long(@hdmiFIFO), 13, 10)
  debug("  hdmiHead:    ", uhex_long(@hdmiHead), 13, 10)
  debug("  oledFIFO:    ", uhex_long(@oledFIFO), 13, 10)
  debug("  oledHead:    ", uhex_long(@oledHead), 13, 10)
  debug("  lock:        ", uhex_long(@lock), 13, 10)

  return true

PUB stop()
  '' Clean shutdown

  if lock >= 0
    lockrel(lock)
    lock := -1

PUB getNextFrame() : framePtr | timeout, poolStart, poolEnd
  '' Get next available frame from pool
  '' Blocks until frame available
  '' Returns pointer to frame buffer

  ' Calculate valid frame pool address range for validation
  poolStart := @framePool
  poolEnd := @framePool + (MAX_FRAMES * FRAME_SIZE)

  timeout := 0
  repeat
    repeat until locktry(lock)
      ' Spin waiting for lock

    if freeCount > 0
      ' CRITICAL: Bounds check before array access
      if freeHead >= MAX_FRAMES
        debug("FIFO FATAL: freeHead=", udec(freeHead), " CORRUPTED! Resetting pool.", 13, 10)
        freeHead := 0
        lockrel(lock)
        return 0
      ' Get frame from free list
      framePtr := LONG[@freeList][freeHead]
      ' CRITICAL: Validate pointer is within frame pool range
      if framePtr < poolStart or framePtr >= poolEnd
        debug("FIFO FATAL: freeList[", udec(freeHead), "] = ", uhex_long(framePtr), " INVALID! Expected ", uhex_long(poolStart), "-", uhex_long(poolEnd), 13, 10)
        debug("  freeList addr=", uhex_long(@freeList + (freeHead << 2)), 13, 10)
        freeHead := (freeHead + 1) // MAX_FRAMES
        freeCount--
        lockrel(lock)
        return 0  ' Return 0 instead of garbage pointer
      freeHead := (freeHead + 1) // MAX_FRAMES
      freeCount--
      lockrel(lock)
      return framePtr

    lockrel(lock)

    ' No frames available, wait a bit
    waitms(1)
    if ++timeout > 1000
      return 0  ' Timeout after 1 second

PUB commitFrame(fifoID, framePtr) : result | poolStart, poolEnd
  '' Commit frame to specified FIFO
  '' Makes frame visible to consumers

  ' Calculate valid frame pool address range for validation
  poolStart := @framePool
  poolEnd := @framePool + (MAX_FRAMES * FRAME_SIZE)

  ' CRITICAL: Validate frame pointer BEFORE acquiring lock
  if framePtr < poolStart or framePtr >= poolEnd
    debug("FIFO FATAL: commitFrame() ptr=", uhex_long(framePtr), " INVALID! Expected ", uhex_long(poolStart), "-", uhex_long(poolEnd), 13, 10)
    return ERR_INVALID

  repeat until locktry(lock)
    ' Spin waiting for lock

  case fifoID
    FIFO_SENSOR:
      if sensorCount < FIFO_DEPTH
        ' CRITICAL: Bounds check tail index before write to prevent memory corruption
        if sensorTail >= FIFO_DEPTH
          debug("FIFO FATAL: sensorTail=", udec(sensorTail), " OVERFLOW! Resetting.", 13, 10)
          sensorTail := 0  ' Emergency reset
        ' Debug disabled for performance - enable when debugging FIFO issues
        'debug("FIFO commit SENSOR: tail=", udec(sensorTail), " addr=", uhex_long(@sensorFIFO + (sensorTail << 2)), " ptr=", uhex_long(framePtr), 13, 10)
        LONG[@sensorFIFO][sensorTail] := framePtr
        sensorTail := (sensorTail + 1) // FIFO_DEPTH
        sensorCount++
        result := SUCCESS
      else
        result := ERR_FULL

    FIFO_HDMI:
      if hdmiCount < FIFO_DEPTH
        ' CRITICAL: Bounds check tail index before write to prevent memory corruption
        if hdmiTail >= FIFO_DEPTH
          debug("FIFO FATAL: hdmiTail=", udec(hdmiTail), " OVERFLOW! Resetting.", 13, 10)
          hdmiTail := 0  ' Emergency reset
        LONG[@hdmiFIFO][hdmiTail] := framePtr
        hdmiTail := (hdmiTail + 1) // FIFO_DEPTH
        hdmiCount++
        result := SUCCESS
      else
        result := ERR_FULL

    FIFO_OLED:
      if oledCount < FIFO_DEPTH
        ' CRITICAL: Bounds check tail index before write to prevent memory corruption
        if oledTail >= FIFO_DEPTH
          debug("FIFO FATAL: oledTail=", udec(oledTail), " OVERFLOW! Resetting.", 13, 10)
          oledTail := 0  ' Emergency reset
        LONG[@oledFIFO][oledTail] := framePtr
        oledTail := (oledTail + 1) // FIFO_DEPTH
        oledCount++
        result := SUCCESS
      else
        result := ERR_FULL

    other:
      result := ERR_INVALID

  lockrel(lock)
  return result

PUB dequeue(fifoID) : framePtr | timeout, poolStart, poolEnd
  '' Dequeue frame from specified FIFO
  '' Blocks until frame available
  '' Returns pointer to frame (or 0 on timeout/error)

  ' Calculate valid frame pool address range for validation
  poolStart := @framePool
  poolEnd := @framePool + (MAX_FRAMES * FRAME_SIZE)

  timeout := 0
  repeat
    repeat until locktry(lock)
      ' Spin waiting for lock

    case fifoID
      FIFO_SENSOR:
        if sensorCount > 0
          ' CRITICAL: Bounds check head index before read to prevent wild memory access
          if sensorHead >= FIFO_DEPTH
            debug("FIFO FATAL: sensorHead=", udec(sensorHead), " CORRUPTED! Resetting FIFO.", 13, 10)
            debug("  sensorHead addr=", uhex_long(@sensorHead), " value=", uhex_long(sensorHead), 13, 10)
            sensorHead := 0
            sensorTail := 0
            sensorCount := 0
            lockrel(lock)
            return 0
          ' Debug: Show exactly what we're reading and from where
          debug("FIFO dequeue SENSOR: head=", udec(sensorHead), " addr=", uhex_long(@sensorFIFO + (sensorHead << 2)), 13, 10)
          framePtr := LONG[@sensorFIFO][sensorHead]
          debug("  read ptr=", uhex_long(framePtr), 13, 10)
          ' CRITICAL: Validate pointer before returning
          if framePtr < poolStart or framePtr >= poolEnd
            debug("FIFO ERROR: Sensor dequeue invalid ptr=", uhex_long(framePtr), " head=", udec(sensorHead), " count=", udec(sensorCount), 13, 10)
            sensorHead := (sensorHead + 1) // FIFO_DEPTH
            sensorCount--
            lockrel(lock)
            return 0  ' Return 0 instead of garbage
          sensorHead := (sensorHead + 1) // FIFO_DEPTH
          sensorCount--
          lockrel(lock)
          return framePtr

      FIFO_HDMI:
        if hdmiCount > 0
          ' CRITICAL: Bounds check head index before read to prevent wild memory access
          if hdmiHead >= FIFO_DEPTH
            debug("FIFO FATAL: hdmiHead=", udec(hdmiHead), " CORRUPTED! Resetting FIFO.", 13, 10)
            hdmiHead := 0
            hdmiTail := 0
            hdmiCount := 0
            lockrel(lock)
            return 0
          framePtr := LONG[@hdmiFIFO][hdmiHead]
          ' CRITICAL: Validate pointer before returning
          if framePtr < poolStart or framePtr >= poolEnd
            debug("FIFO ERROR: HDMI dequeue invalid ptr=", uhex_long(framePtr), " head=", udec(hdmiHead), " count=", udec(hdmiCount), 13, 10)
            hdmiHead := (hdmiHead + 1) // FIFO_DEPTH
            hdmiCount--
            lockrel(lock)
            return 0  ' Return 0 instead of garbage
          hdmiHead := (hdmiHead + 1) // FIFO_DEPTH
          hdmiCount--
          lockrel(lock)
          return framePtr

      FIFO_OLED:
        if oledCount > 0
          ' CRITICAL: Bounds check head index before read to prevent wild memory access
          if oledHead >= FIFO_DEPTH
            debug("FIFO FATAL: oledHead=", udec(oledHead), " CORRUPTED! Resetting FIFO.", 13, 10)
            oledHead := 0
            oledTail := 0
            oledCount := 0
            lockrel(lock)
            return 0
          framePtr := LONG[@oledFIFO][oledHead]
          ' CRITICAL: Validate pointer before returning
          if framePtr < poolStart or framePtr >= poolEnd
            debug("FIFO ERROR: OLED dequeue invalid ptr=", uhex_long(framePtr), " head=", udec(oledHead), " count=", udec(oledCount), 13, 10)
            oledHead := (oledHead + 1) // FIFO_DEPTH
            oledCount--
            lockrel(lock)
            return 0  ' Return 0 instead of garbage
          oledHead := (oledHead + 1) // FIFO_DEPTH
          oledCount--
          lockrel(lock)
          return framePtr

      other:
        lockrel(lock)
        return 0

    lockrel(lock)

    ' No frames available, wait
    waitms(1)
    if ++timeout > 1000
      return 0  ' Timeout

PUB releaseFrame(framePtr) | poolStart, poolEnd
  '' Return frame to free pool
  '' Called by consumers when done with frame

  if framePtr == 0
    return

  ' Calculate valid frame pool address range for validation
  poolStart := @framePool
  poolEnd := @framePool + (MAX_FRAMES * FRAME_SIZE)

  ' CRITICAL: Validate frame pointer BEFORE acquiring lock
  if framePtr < poolStart or framePtr >= poolEnd
    debug("FIFO FATAL: releaseFrame() ptr=", uhex_long(framePtr), " INVALID! Expected ", uhex_long(poolStart), "-", uhex_long(poolEnd), 13, 10)
    return  ' Don't corrupt freeList with garbage pointer

  repeat until locktry(lock)
    ' Spin waiting for lock

  if freeCount < MAX_FRAMES
    freeTail := (freeTail + 1) // MAX_FRAMES  ' Move tail first
    ' CRITICAL: Bounds check before array write
    if freeTail >= MAX_FRAMES
      debug("FIFO FATAL: freeTail=", udec(freeTail), " CORRUPTED! Resetting.", 13, 10)
      freeTail := 0
    LONG[@freeList][freeTail] := framePtr       ' Then insert
    freeCount++

  lockrel(lock)

PUB getQueueDepth(fifoID) : count
  '' Get current number of frames in specified FIFO

  repeat until locktry(lock)
    ' Spin waiting for lock

  case fifoID
    FIFO_SENSOR: count := sensorCount
    FIFO_HDMI:   count := hdmiCount
    FIFO_OLED:   count := oledCount
    other:       count := -1

  lockrel(lock)

PUB getFreeFrames() : count
  '' Get number of available frames in pool

  repeat until locktry(lock)
    ' Spin waiting for lock

  count := freeCount
  lockrel(lock)

PUB getFreeListAddr() : addr
  '' Get address of freeList array (for debugging/watchpoints)
  return @freeList

PUB getFramePoolAddr() : addr
  '' Get address of frame pool (for debugging/watchpoints)
  return @framePool

PUB checkFreeListIntegrity() : corrupted | i, ptr, poolStart, poolEnd
  '' Check if any freeList entry has been corrupted
  '' Call this periodically from main loop to detect corruption moment
  '' Returns index of first corrupted entry, or -1 if all OK

  poolStart := @framePool
  poolEnd := @framePool + (MAX_FRAMES * FRAME_SIZE)

  repeat i from 0 to MAX_FRAMES - 1
    ptr := LONG[@freeList][i]
    if ptr <> 0  ' 0 means slot is empty (already allocated)
      if ptr < poolStart or ptr >= poolEnd
        debug("WATCHPOINT: freeList[", udec(i), "] = ", uhex_long(ptr), " CORRUPTED!", 13, 10)
        return i

  return -1  ' All OK