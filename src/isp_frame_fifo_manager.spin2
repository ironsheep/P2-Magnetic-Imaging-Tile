'' isp_frame_fifo_manager.spin2 - Multi-FIFO Frame Pool Manager
'' Zero-copy architecture with three independent FIFOs sharing a common frame pool
''
'' FIFOs:
''   - FIFO_SENSOR: Sensor -> Frame Processor
''   - FIFO_HDMI:   Frame Processor -> HDMI Display Engine
''   - FIFO_OLED:   Frame Processor -> OLED Manager

CON
  ' FIFO IDs
  FIFO_SENSOR = 0
  FIFO_HDMI   = 1
  FIFO_OLED   = 2

  ' Frame configuration
  FRAME_SIZE  = 128         ' 64 sensors x 2 bytes each
  MAX_FRAMES  = 32          ' Total frames in pool
  FIFO_DEPTH  = 16          ' Max entries per FIFO

  ' Return codes
  SUCCESS     = 0
  ERR_FULL    = -1
  ERR_EMPTY   = -2
  ERR_INVALID = -3

DAT
  ' Singleton shared state - all instances reference this same data
  ' This enables zero-copy frame sharing across all subsystems

  ' Frame pool - all frames live here
  framePool       byte  0[MAX_FRAMES * FRAME_SIZE]

  ' Free frame tracking
  freeList        long  0[MAX_FRAMES]
  freeHead        long  0
  freeTail        long  0
  freeCount       long  0

  ' FIFO structures - just hold pointers
  sensorFIFO      long  0[FIFO_DEPTH]
  sensorHead      long  0
  sensorTail      long  0
  sensorCount     long  0

  hdmiFIFO        long  0[FIFO_DEPTH]
  hdmiHead        long  0
  hdmiTail        long  0
  hdmiCount       long  0

  oledFIFO        long  0[FIFO_DEPTH]
  oledHead        long  0
  oledTail        long  0
  oledCount       long  0

  ' Lock for atomic operations
  lock            long  -1  ' -1 = uninitialized

PUB null()
  '' Not a top-level object

PUB start() : ok | i
  '' Initialize the frame pool and all FIFOs

  debug("FIFO: Acquiring lock...", 13, 10)
  lock := locknew()
  debug("FIFO: Lock acquired: ", sdec(lock), 13, 10)

  ' CRITICAL: Explicitly zero ALL FIFO arrays to prevent garbage pointer issues
  ' DAT section initialization may not reliably zero arrays
  debug("FIFO: Zeroing FIFO arrays...", 13, 10)
  longfill(@sensorFIFO, 0, FIFO_DEPTH)
  longfill(@hdmiFIFO, 0, FIFO_DEPTH)
  longfill(@oledFIFO, 0, FIFO_DEPTH)
  longfill(@freeList, 0, MAX_FRAMES)

  ' Initialize free list with all frames
  debug("FIFO: Initializing ", udec(MAX_FRAMES), " frames...", 13, 10)
  repeat i from 0 to MAX_FRAMES-1
    freeList[i] := @framePool + (i * FRAME_SIZE)

  freeHead := 0
  freeTail := MAX_FRAMES - 1  ' CORRECT: Knuth's algorithm with count (full queue, next enqueue wraps to 0)
  freeCount := MAX_FRAMES

  debug("FIFO: freeCount = ", udec(freeCount), ", freeHead = ", udec(freeHead), ", freeTail = ", udec(freeTail), 13, 10)

  ' Initialize all FIFOs as empty
  sensorHead := sensorTail := sensorCount := 0
  hdmiHead := hdmiTail := hdmiCount := 0
  oledHead := oledTail := oledCount := 0

  debug("FIFO: Initialization complete", 13, 10)


  return true

PUB stop()
  '' Clean shutdown

  if lock >= 0
    lockrel(lock)
    lock := -1

PUB getNextFrame() : framePtr | timeout
  '' Get next available frame from pool
  '' Blocks until frame available
  '' Returns pointer to frame buffer

  timeout := 0
  repeat
    repeat until locktry(lock)
      ' Spin waiting for lock

    if freeCount > 0
      ' Get frame from free list
      framePtr := freeList[freeHead]
      freeHead := (freeHead + 1) // MAX_FRAMES
      freeCount--
      lockrel(lock)
      return framePtr

    lockrel(lock)

    ' No frames available, wait a bit
    waitms(1)
    if ++timeout > 1000
      return 0  ' Timeout after 1 second

PUB commitFrame(fifoID, framePtr) : result
  '' Commit frame to specified FIFO
  '' Makes frame visible to consumers

  repeat until locktry(lock)
    ' Spin waiting for lock

  case fifoID
    FIFO_SENSOR:
      if sensorCount < FIFO_DEPTH
        sensorFIFO[sensorTail] := framePtr
        sensorTail := (sensorTail + 1) // FIFO_DEPTH
        sensorCount++
        result := SUCCESS
      else
        result := ERR_FULL

    FIFO_HDMI:
      if hdmiCount < FIFO_DEPTH
        hdmiFIFO[hdmiTail] := framePtr
        hdmiTail := (hdmiTail + 1) // FIFO_DEPTH
        hdmiCount++
        result := SUCCESS
      else
        result := ERR_FULL

    FIFO_OLED:
      if oledCount < FIFO_DEPTH
        oledFIFO[oledTail] := framePtr
        oledTail := (oledTail + 1) // FIFO_DEPTH
        oledCount++
        result := SUCCESS
      else
        result := ERR_FULL

    other:
      result := ERR_INVALID

  lockrel(lock)
  return result

PUB dequeue(fifoID) : framePtr | timeout, poolStart, poolEnd
  '' Dequeue frame from specified FIFO
  '' Blocks until frame available
  '' Returns pointer to frame (or 0 on timeout/error)

  ' Calculate valid frame pool address range for validation
  poolStart := @framePool
  poolEnd := @framePool + (MAX_FRAMES * FRAME_SIZE)

  timeout := 0
  repeat
    repeat until locktry(lock)
      ' Spin waiting for lock

    case fifoID
      FIFO_SENSOR:
        if sensorCount > 0
          framePtr := sensorFIFO[sensorHead]
          ' CRITICAL: Validate pointer before returning
          if framePtr < poolStart or framePtr >= poolEnd
            debug("FIFO ERROR: Sensor dequeue invalid ptr=", uhex_long(framePtr), " head=", udec(sensorHead), " count=", udec(sensorCount), 13, 10)
            sensorHead := (sensorHead + 1) // FIFO_DEPTH
            sensorCount--
            lockrel(lock)
            return 0  ' Return 0 instead of garbage
          sensorHead := (sensorHead + 1) // FIFO_DEPTH
          sensorCount--
          lockrel(lock)
          return framePtr

      FIFO_HDMI:
        if hdmiCount > 0
          framePtr := hdmiFIFO[hdmiHead]
          ' CRITICAL: Validate pointer before returning
          if framePtr < poolStart or framePtr >= poolEnd
            debug("FIFO ERROR: HDMI dequeue invalid ptr=", uhex_long(framePtr), " head=", udec(hdmiHead), " count=", udec(hdmiCount), 13, 10)
            hdmiHead := (hdmiHead + 1) // FIFO_DEPTH
            hdmiCount--
            lockrel(lock)
            return 0  ' Return 0 instead of garbage
          hdmiHead := (hdmiHead + 1) // FIFO_DEPTH
          hdmiCount--
          lockrel(lock)
          return framePtr

      FIFO_OLED:
        if oledCount > 0
          framePtr := oledFIFO[oledHead]
          ' CRITICAL: Validate pointer before returning
          if framePtr < poolStart or framePtr >= poolEnd
            debug("FIFO ERROR: OLED dequeue invalid ptr=", uhex_long(framePtr), " head=", udec(oledHead), " count=", udec(oledCount), 13, 10)
            oledHead := (oledHead + 1) // FIFO_DEPTH
            oledCount--
            lockrel(lock)
            return 0  ' Return 0 instead of garbage
          oledHead := (oledHead + 1) // FIFO_DEPTH
          oledCount--
          lockrel(lock)
          return framePtr

      other:
        lockrel(lock)
        return 0

    lockrel(lock)

    ' No frames available, wait
    waitms(1)
    if ++timeout > 1000
      return 0  ' Timeout

PUB releaseFrame(framePtr)
  '' Return frame to free pool
  '' Called by consumers when done with frame

  if framePtr == 0
    return

  repeat until locktry(lock)
    ' Spin waiting for lock

  if freeCount < MAX_FRAMES
    freeTail := (freeTail + 1) // MAX_FRAMES  ' Move tail first
    freeList[freeTail] := framePtr             ' Then insert
    freeCount++

  lockrel(lock)

PUB getQueueDepth(fifoID) : count
  '' Get current number of frames in specified FIFO

  repeat until locktry(lock)
    ' Spin waiting for lock

  case fifoID
    FIFO_SENSOR: count := sensorCount
    FIFO_HDMI:   count := hdmiCount
    FIFO_OLED:   count := oledCount
    other:       count := -1

  lockrel(lock)

PUB getFreeFrames() : count
  '' Get number of available frames in pool

  repeat until locktry(lock)
    ' Spin waiting for lock

  count := freeCount
  lockrel(lock)