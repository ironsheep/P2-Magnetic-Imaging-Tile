'' =================================================================================================
''   File....... isp_tile_sensor.spin2
''   Purpose.... Magnetic Imaging Tile sensor interface - Single COG architecture
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Nov 2025
''
''   Architecture: Single COG with inline PASM for sensor acquisition
''                Similar to isp_oled_single_cog.spin2 pattern
''
'' =================================================================================================

CON { tile sensor constants }

    ' Hardware pin group assignment (fixed for this project)
    TILE_PIN_GROUP  = 8                 ' Magnetic tile on P8-P15

    ' Pin assignments (relative to pin group)
    PIN_CS          = 0                 ' +0 - AD7680 Chip Select (VIOLET)
    PIN_CCLK        = 1                 ' +1 - Counter Clock (WHITE)
    PIN_MISO        = 2                 ' +2 - AD7680 Data Input (BLUE)
    PIN_CLRB        = 3                 ' +3 - Counter Clear (GRAY)
    PIN_SCLK        = 4                 ' +4 - AD7680 SPI Clock (GREEN)
    PIN_AOUT        = 6                 ' +6 - Analog Input (YELLOW)

    ' Absolute pin numbers (constants for fixed pin group)
    ABS_PIN_CS      = TILE_PIN_GROUP + PIN_CS
    ABS_PIN_CCLK    = TILE_PIN_GROUP + PIN_CCLK
    ABS_PIN_MISO    = TILE_PIN_GROUP + PIN_MISO
    ABS_PIN_CLRB    = TILE_PIN_GROUP + PIN_CLRB
    ABS_PIN_SCLK    = TILE_PIN_GROUP + PIN_SCLK
    ABS_PIN_AOUT    = TILE_PIN_GROUP + PIN_AOUT

    ' Pin field for all 5 control pins (11-bit encoded constant)
    CONTROL_PINS_FIELD = ABS_PIN_CS ADDPINS 4  ' CS through SCLK (5 pins total)

    ' Sensor array configuration
    SENSORS_PER_FRAME = 64              ' 8x8 sensor array
    SUBTILES = 4                        ' 4 quadrants
    SENSORS_PER_SUBTILE = 16            ' 4x4 per subtile

    ' ADC configuration - AD7940 (14-bit ADC, 16-bit SPI frame)
    ' Frame format: 2 leading zeros + 14-bit data = 16 bits total
    ADC_BITS = 14                       ' AD7940 is 14-bit ADC
    ADC_MAX_VALUE = (1 << ADC_BITS) - 1 ' Maximum ADC reading (16383)
    SPI_TRANSFER_BITS = 16              ' Total SPI transfer size (2 leading + 14 data)

    ' Timing constants @ 250 MHz system clock (1 clock = 4ns)
    SENSOR_SETTLE_DELAY = 500           ' 2000ns (2µs) for analog settling - used for first sensor only
    COUNTER_SETUP_DELAY = 63            ' 250ns after counter operations
    RESIDUAL_SETTLE_DELAY = 200         ' 800ns additional settle after SPI completes (pipelined mode)
    FRAME_PERIOD_MS = 3                 ' ~333 fps target frame rate (@ 250 MHz)

    ' Smart Pin SPI configuration (P_PULSE mode like jm_ez_spi)
    SPI_CLOCK_FREQ = 2_500_000          ' 2.5 MHz SPI clock (AD7680 maximum)
    SPI_PERIOD = 250_000_000 / SPI_CLOCK_FREQ  ' Period in sysclks = 100 @ 250 MHz
    SPI_LOW_TIME = SPI_PERIOD / 2       ' 50% duty cycle = 50 sysclks

OBJ
    fifo : "isp_frame_fifo_manager"    ' Multi-FIFO frame pool manager (shared singleton)
    stack_check : "isp_stack_check"    ' Stack overflow detection utility

CON { stack configuration }

    SENSOR_STACK_SIZE_LONGS = 128       ' Stack size for sensor COG (increased from 64 - was causing overflow)

VAR { tile sensor variables }

    LONG    cog_id                      ' Sensor COG ID (-1 = stopped, >=0 = running)
    LONG    frame_count                 ' Total frames captured
    LONG    error_count                 ' SPI/sensor error count
    LONG    acquisition_mode            ' Current acquisition mode
    LONG    base_pin                    ' Base pin for sensor interface

    ' Baseline calibration
    WORD    baseline[SENSORS_PER_FRAME] ' Zero-field baseline values (64 sensors)
    LONG    baseline_valid              ' TRUE if baseline has been calibrated

    ' Test pattern state
    LONG    test_frame_counter          ' Test mode: current frame index (0-5)

CON { acquisition modes }

    #0                              ' Start enumeration at 0
    MODE_STOPPED                    ' = 0
    MODE_LIVE                       ' = 1
    MODE_HIGH_SPEED                 ' = 2
    MODE_DEBUG                      ' = 3
    MODE_TEST_PATTERN               ' = 4

DAT { sensor COG stack with overflow detection }

    ' Stack for sensor COG - placed in DAT with sentinel mark for overflow detection
    sensor_cog_stack    LONG    0[SENSOR_STACK_SIZE_LONGS]
    sensor_stack_mark   LONG    stack_check.DO_NOT_WRITE_MARK   ' Sentinel - overflow if overwritten

DAT { sensor mapping arrays }

    ' Subtile reading order: scan subtiles 0, 2, 1, 3 (not sequential!)
    subtile_order   BYTE    0, 2, 1, 3

    ' Frame buffer offsets for each subtile (words)
    subtile_offset  BYTE    0, 4, 32, 36

    ' Pixel mapping within each subtile (serpentine pattern)
    ' Maps counter position (0-15) to frame buffer position within subtile
    pixel_order     BYTE    26, 27, 18, 19, 10, 11, 2, 3
                    BYTE    1, 0, 9, 8, 17, 16, 25, 24

PUB null()
'' This is not a top-level object
'' @returns nothing - placeholder method for non-top-level object
    cog_id := -1

PUB start(sensor_base_pin) : success
'' Start the tile sensor single-COG driver
'' @param sensor_base_pin - base pin for sensor interface
'' @returns TRUE if successful, FALSE if failed to start

    ' Initialize COG ID FIRST (critical - must be set before any checks!)
    if cog_id == 0
        cog_id := -1

    if cog_id >= 0
        return TRUE                     ' Already running

    ' Save pin configuration
    base_pin := sensor_base_pin

    ' Initialize variables
    frame_count := 0
    error_count := 0
    acquisition_mode := MODE_LIVE       ' Start in live mode
    baseline_valid := FALSE             ' No baseline until calibrated
    test_frame_counter := 0

    ' Prepare stack for overflow detection
    stack_check.prepStackForCheck(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)

    ' Launch sensor COG
    debug("Sensor: Launching single-COG driver...", 13, 10)
    cog_id := cogspin(NEWCOG, sensor_loop(), @sensor_cog_stack)

    if cog_id < 0
        debug("Sensor: ERROR - COG launch failed!", 13, 10)
        return FALSE

    debug("Sensor: COG ", udec(cog_id), " launched successfully", 13, 10)
    return TRUE

PUB stop()
'' Stop the tile sensor and terminate COG operation

    if cog_id >= 0 and cog_id <= 7
        cogstop(cog_id)
    cog_id := -1

PUB set_acquisition_mode(mode)
'' Set the sensor acquisition mode
'' @param mode - acquisition mode: MODE_STOPPED, MODE_LIVE, MODE_TEST_PATTERN, etc.

    acquisition_mode := mode

PUB get_frame_count() : count
'' Get total number of frames captured since start
'' @returns total frame count as LONG

    return frame_count

PUB get_error_count() : count
'' Get total number of SPI/sensor errors encountered
'' @returns error count as LONG

    return error_count

PUB is_running() : state
'' Check if sensor background cog is currently running
'' @returns TRUE if running, FALSE if stopped

    return (cog_id >= 0)

PUB reset_counter_test()
'' TEST METHOD: Reset hardware counter to sensor 0
'' Pulses CLRb low to reset multiplexer counter
'' @note For regression testing only - validates counter control

    debug("TEST: reset_counter_test() called", 13, 10)
    org
        drvl    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY
        drvh    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY
    end
    debug("TEST: reset_counter_test() completed", 13, 10)

PUB advance_counter_test()
'' TEST METHOD: Advance hardware counter to next sensor
'' Pulses CCLK high to increment multiplexer counter
'' @note For regression testing only - validates counter control

    org
        drvl    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
    end

PUB read_single_sensor() : sensor_value | raw_value, event_config
'' TEST METHOD: Read current sensor using smart pin SPI interface
'' Uses P_PULSE clock mode for reliable operation
'' OPTIMIZED (Nov 2025): No per-transfer reset, uses waitse1 instead of polling
'' @returns 16-bit sensor value (0-65535)
'' @note For regression testing only - tests smart pin sync RX/clock generation
'' @note configure_smart_pins() must be called first!

    ' Build event configuration (needed for inline PASM in Spin2 context)
    event_config := %01_000000 | ABS_PIN_SCLK

    org
        ' Configure event for this read (Spin2 inline PASM doesn't share COG's setse1)
        setse1  event_config

        ' Start ADC conversion (CS low - captures analog value)
        drvl    #ABS_PIN_CS
        waitx   #SENSOR_SETTLE_DELAY

        ' Trigger SPI clock pulses (P_PULSE mode: wypin = number of pulses = bits)
        wypin   #SPI_TRANSFER_BITS, #ABS_PIN_SCLK    ' Generate 24 clock pulses
        akpin   #ABS_PIN_SCLK                        ' Clear any stale IN flag
        waitse1                                      ' Wait efficiently for completion

        ' Clock finished - read received data from MISO
        rdpin   raw_value, #ABS_PIN_MISO             ' Read 16-bit value (left-justified, LSB-first)

        ' End conversion (CS high)
        drvh    #ABS_PIN_CS

        ' Process data: AD7940 sends MSB-first, but P_SYNC_RX receives LSB-first
        ' After REV, the 16-bit frame is in Z[15:0] (right-justified)
        ' AD7940 frame: 1 leading zero + 14-bit data + 1 trailing zero
        ' After REV: Z[15]=trailing, Z[14:1]=data, Z[0]=leading
        rev     raw_value                            ' Reverse all 32 bits (MSB-first now, right-justified)
        shr     raw_value, #1                        ' Shift out 1 trailing zero
        and     raw_value, ##$3FFF                   ' Mask to 14 bits
        mov     sensor_value, raw_value
    end

PUB configure_smart_pins() | sclk_x, event_config
'' Configure smart pins for SPI communication with AD7680
'' Uses P_PULSE mode for clock (like jm_ez_spi) - more reliable than P_TRANSITION
'' Called ONCE before using test methods or by sensor COG at startup
'' @note Public to allow test code to configure pins explicitly
''
'' OPTIMIZATION (Nov 2025): Smart pins are configured ONCE here and maintain
'' their settings across transfers. No need to reset/reconfigure per-transfer.
'' Also configures event SE1 for efficient waitse1-based waiting.

    debug("Sensor: Configuring smart pins for SPI (P_PULSE mode + events)...", 13, 10)

    ' Build SCLK X register: X[15:0]=period, X[31:16]=low_time
    sclk_x := SPI_PERIOD | (SPI_LOW_TIME << 16)

    ' Build event configuration: %01 = positive edge, pin number in lower 6 bits
    event_config := %01_000000 | ABS_PIN_SCLK

    org
        ' Configure SCLK (P12) as pulse output (SPI clock generator)
        ' P_PULSE mode: wypin sets pulse count, pin generates that many clock cycles
        dirl    #ABS_PIN_SCLK                        ' Clear/reset smart pin
        wrpin   ##P_PULSE | P_OE, #ABS_PIN_SCLK      ' Pulse mode for clock generation
        wxpin   sclk_x, #ABS_PIN_SCLK                ' X[15:0]=period, X[31:16]=low_time
        dirh    #ABS_PIN_SCLK                        ' Enable smart pin

        ' Configure MISO (P10) as sync serial RX (data receiver)
        ' SCLK is 2 pins away (P12), so use P_PLUS2_B to specify B-input source
        ' P_INVERT_B: AD7680 outputs data on FALLING edge, so invert clock sense
        ' OPTIMIZATION: Configure ONCE and leave enabled - no per-transfer reset needed
        dirl    #ABS_PIN_MISO                        ' Clear/reset smart pin
        wrpin   ##P_SYNC_RX | P_PLUS2_B | P_INVERT_B, #ABS_PIN_MISO ' Sync RX, clock from pin+2, sample on falling edge
        wxpin   #%0_10111, #ABS_PIN_MISO             ' Pre-edge sample, 24 bits (bit_count-1 = 23)
        dirh    #ABS_PIN_MISO                        ' Enable MISO - stays enabled!

        ' Configure event SE1 for SCLK completion (positive edge on IN flag)
        ' This enables efficient waitse1 instead of polling loop
        setse1  event_config

        ' Configure CS, CCLK, CLRb as normal digital outputs with initial states
        drvh    #ABS_PIN_CS                          ' CS high (inactive)
        drvl    #ABS_PIN_CCLK                        ' CCLK low
        drvh    #ABS_PIN_CLRB                        ' CLRb high (not clearing)
    end

    debug("Sensor: Smart pins configured (MISO stays enabled, SE1 event ready)", 13, 10)

PRI sensor_loop() | framePtr, patternPtr, subtile_idx, sensor_idx, subtile_num, frame_offset, sensor_in_subtile, pixel_pos, sensor_val
'' Main sensor loop running in dedicated COG
'' Handles both test pattern generation and live sensor acquisition

    debug("Sensor: COG loop started", 13, 10)

    ' CRITICAL: Show stack address to diagnose memory corruption
    debug("SENSOR STACK: ", uhex_long(@sensor_cog_stack), " to ", uhex_long(@sensor_cog_stack + (SENSOR_STACK_SIZE_LONGS * 4) - 1), 13, 10)

    ' Configure smart pins for SPI (ONCE at startup)
    stack_check.checkStack(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)
    configure_smart_pins()
    stack_check.checkStack(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)

    repeat
        ' Check for stack overflow (halts with debug message if detected)
        stack_check.checkStack(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)

        ' Check acquisition mode
        case acquisition_mode
            MODE_STOPPED:
                waitms(10)
                next

            MODE_TEST_PATTERN:
                ' Generate test patterns (Spin2)
                generate_test_frame()

            MODE_LIVE:
                ' Acquire live sensor data
                acquire_sensor_frame()

            OTHER:
                waitms(10)

PRI generate_test_frame() | framePtr, patternPtr
'' Generate test pattern frame (digits 0-5)

    ' Get frame buffer from FIFO
    framePtr := fifo.getNextFrame()
    if framePtr == 0
        waitms(1)
        return

    ' Select pattern based on counter
    case test_frame_counter
        0: patternPtr := @digit_0_pattern
        1: patternPtr := @digit_1_pattern
        2: patternPtr := @digit_2_pattern
        3: patternPtr := @digit_3_pattern
        4: patternPtr := @digit_4_pattern
        5: patternPtr := @digit_5_pattern

    ' Copy pattern to frame buffer (64 WORDs = 128 bytes)
    WORDMOVE(framePtr, patternPtr, 64)

    ' Commit frame to sensor FIFO
    if fifo.commitFrame(fifo.FIFO_SENSOR, framePtr) < 0
        fifo.releaseFrame(framePtr)
    else
        frame_count++

    ' Increment test counter
    test_frame_counter++
    if test_frame_counter >= 6
        test_frame_counter := 0
        waitms(1000)  ' 1 second between test pattern cycles
    else
        waitms(100)   ' 100ms between individual patterns

PRI acquire_sensor_frame() | framePtr, subtile_idx, sensor_in_subtile, subtile_num, frame_offset, pixel_pos, sensor_val, buf_ptr, total_sensor_count, lut_subtile_order, lut_subtile_offset, lut_pixel_order
'' Acquire live sensor frame using inline PASM for timing-critical operations
'' OPTIMIZED (Nov 2025): Pipelined counter advance during SPI transfer
''
'' Pipeline strategy:
''   - First sensor: Full settle wait, then start SPI
''   - During SPI: Advance counter to NEXT sensor (overlaps with SPI time)
''   - After SPI: Small residual settle, read data, store
''   - Subsequent sensors: Already settled from previous iteration
''
'' This hides ~2.75µs of counter/settle time inside the 9.6µs SPI transfer

    ' Get frame buffer from FIFO
    framePtr := fifo.getNextFrame()
    debug("SENSOR: GET ptr=", uhex_long(framePtr), 13, 10)
    if framePtr == 0
        waitms(1)
        return

    ' CRITICAL: Pre-load all lookup table addresses BEFORE inline PASM
    ' This avoids modifying ptra inside PASM which corrupts stack access
    lut_subtile_order := @subtile_order
    lut_subtile_offset := @subtile_offset
    lut_pixel_order := @pixel_order

    ' Use inline PASM to read all 64 sensors with pipelined counter advance
    ' NOTE: We use pa, pb for temporary pointers instead of ptra to avoid
    ' corrupting Spin2's stack pointer
    ORG
        ' Jump to main code (subroutines placed first for backward reference only)
        jmp     #.main_start

' ============================================
' Subroutines (placed first so all calls are backward references)
' ============================================

' store_sensor_value: Map and store sensor reading
' Uses: subtile_idx, sensor_in_subtile, sensor_val, framePtr
' Uses pa as temp pointer (NOT ptra - that breaks Spin2 stack access!)
' Modifies: pa, pixel_pos, frame_offset, buf_ptr, subtile_num
.store_sensor_value
        ' Get current subtile number from subtile_order array
        mov     pa, lut_subtile_order
        add     pa, subtile_idx
        rdbyte  subtile_num, pa

        ' Get frame buffer offset for this subtile
        mov     pa, lut_subtile_offset
        add     pa, subtile_num
        rdbyte  frame_offset, pa

        ' Map sensor position using pixel_order lookup
        mov     pa, lut_pixel_order
        add     pa, sensor_in_subtile
        rdbyte  pixel_pos, pa

        ' Calculate final frame buffer position
        mov     buf_ptr, pixel_pos
        add     buf_ptr, frame_offset
        shl     buf_ptr, #1                    ' Convert to byte offset (* 2 for WORD)
        add     buf_ptr, framePtr              ' Add frame base address

        ' Store value in frame buffer
        wrword  sensor_val, buf_ptr
        ret

' advance_subtile: Move to next subtile
' Modifies: subtile_idx, sensor_in_subtile
.advance_subtile
        add     subtile_idx, #1
        mov     sensor_in_subtile, #0
        ret

' ============================================
' Main acquisition code
' ============================================
.main_start
        ' framePtr already contains the frame buffer address from Spin2

        ' Reset sensor counter to position 0
        drvl    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY
        drvh    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY

        ' Advance to sensor 1 (first active sensor per documentation)
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY

        ' Initialize total sensor counter (0-63)
        mov     total_sensor_count, #0

        ' ========== FIRST SENSOR: Full settle required ==========
        ' CS low to capture analog value
        drvl    #ABS_PIN_CS
        waitx   #SENSOR_SETTLE_DELAY              ' Full settle for first sensor

        ' Start SPI transfer for sensor 0
        wypin   #SPI_TRANSFER_BITS, #ABS_PIN_SCLK
        akpin   #ABS_PIN_SCLK

        ' WHILE SPI RUNS: Advance counter to sensor 1
        ' (sensor 1 starts settling now, will be ready by next read)
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        ' Mux now switching to sensor 1, settling begins

        ' Wait for SPI to complete
        waitse1

        ' Read and process sensor 0 data (AD7940: 1 leading + 14 data + 1 trailing)
        rdpin   sensor_val, #ABS_PIN_MISO
        drvh    #ABS_PIN_CS
        rev     sensor_val
        shr     sensor_val, #1              ' Shift out 1 trailing zero
        and     sensor_val, ##$3FFF         ' Mask to 14 bits

        ' Store sensor 0 using mapping lookup
        mov     subtile_idx, #0
        mov     sensor_in_subtile, #0
        call    #.store_sensor_value

        ' Increment counters
        add     sensor_in_subtile, #1
        add     total_sensor_count, #1

        ' ========== SENSORS 1-62: Pipelined (already settling) ==========
.pipelined_loop
        ' Residual settle time (sensor was advancing during previous SPI)
        waitx   #RESIDUAL_SETTLE_DELAY

        ' CS low - analog value already stable
        drvl    #ABS_PIN_CS

        ' Start SPI transfer for current sensor
        wypin   #SPI_TRANSFER_BITS, #ABS_PIN_SCLK
        akpin   #ABS_PIN_SCLK

        ' Check if this is the last sensor (>= 63, defensive)
        cmp     total_sensor_count, #63 wcz
  if_ae jmp     #.last_sensor

        ' WHILE SPI RUNS: Advance counter to NEXT sensor
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        ' Next sensor now settling...

        ' Wait for SPI to complete
        waitse1

        ' Read and process current sensor data (AD7940: 1 leading + 14 data + 1 trailing)
        rdpin   sensor_val, #ABS_PIN_MISO
        drvh    #ABS_PIN_CS
        rev     sensor_val
        shr     sensor_val, #1              ' Shift out 1 trailing zero
        and     sensor_val, ##$3FFF         ' Mask to 14 bits

        ' Store using mapping lookup
        call    #.store_sensor_value

        ' Update subtile tracking
        add     sensor_in_subtile, #1
        cmp     sensor_in_subtile, #16 wz
  if_z  call    #.advance_subtile

        ' Loop for next sensor
        add     total_sensor_count, #1
        jmp     #.pipelined_loop

        ' ========== LAST SENSOR (63): No counter advance needed ==========
.last_sensor
        ' Wait for SPI to complete (no counter advance - we're done)
        waitse1

        ' Read and process final sensor data (AD7940: 1 leading + 14 data + 1 trailing)
        rdpin   sensor_val, #ABS_PIN_MISO
        drvh    #ABS_PIN_CS
        rev     sensor_val
        shr     sensor_val, #1              ' Shift out 1 trailing zero
        and     sensor_val, ##$3FFF         ' Mask to 14 bits

        ' Store final sensor
        call    #.store_sensor_value

        ' Frame acquisition complete
        ' NOTE: We no longer need to restore ptra because we never modified it!
        ' Using pa instead of ptra for lookup pointers preserves Spin2 stack access

    END

    ' Commit completed frame to sensor FIFO
    debug("SENSOR: COMMIT ptr=", uhex_long(framePtr), 13, 10)
    if fifo.commitFrame(fifo.FIFO_SENSOR, framePtr) < 0
        ' FIFO full - release frame back to pool
        debug("SENSOR: RELEASE (full) ptr=", uhex_long(framePtr), 13, 10)
        fifo.releaseFrame(framePtr)
    else
        ' Frame committed successfully
        frame_count++

    ' Minimal delay - decimator debug removed so it can keep up
    waitus(10)                          ' 10 us gap - ~1,370 fps max

DAT { test pattern digit data - 8x8 WORD arrays in HUB memory }

' Each digit is 64 WORDs (128 bytes) representing an 8x8 grid
' Background: $0100, Digit pixels use unique values for color differentiation

digit_0_pattern         ' Digit "0" - 0x1000
        WORD    $0100, $1000, $1000, $1000, $1000, $1000, $1000, $0100
        WORD    $1000, $1000, $0100, $0100, $0100, $0100, $1000, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $1000, $0100, $0100, $0100, $0100, $1000, $1000
        WORD    $0100, $1000, $1000, $1000, $1000, $1000, $1000, $0100

digit_1_pattern         ' Digit "1" - 0x2000
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $2000, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100

digit_2_pattern         ' Digit "2" - 0x3000
        WORD    $0100, $3000, $3000, $3000, $3000, $3000, $0100, $0100
        WORD    $3000, $3000, $0100, $0100, $0100, $3000, $3000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $3000, $3000, $0100
        WORD    $0100, $0100, $0100, $0100, $3000, $3000, $0100, $0100
        WORD    $0100, $0100, $0100, $3000, $3000, $0100, $0100, $0100
        WORD    $0100, $0100, $3000, $3000, $0100, $0100, $0100, $0100
        WORD    $0100, $3000, $3000, $0100, $0100, $0100, $0100, $0100
        WORD    $3000, $3000, $3000, $3000, $3000, $3000, $3000, $0100

digit_3_pattern         ' Digit "3" - 0x4000
        WORD    $0100, $4000, $4000, $4000, $4000, $4000, $0100, $0100
        WORD    $4000, $4000, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $0100, $4000, $4000, $4000, $4000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $4000, $4000, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $4000, $4000, $4000, $4000, $4000, $0100, $0100

digit_4_pattern         ' Digit "4" - 0x5000
        WORD    $0100, $0100, $0100, $5000, $5000, $5000, $0100, $0100
        WORD    $0100, $0100, $5000, $5000, $5000, $5000, $0100, $0100
        WORD    $0100, $5000, $5000, $0100, $5000, $5000, $0100, $0100
        WORD    $5000, $5000, $0100, $0100, $5000, $5000, $0100, $0100
        WORD    $5000, $5000, $5000, $5000, $5000, $5000, $5000, $0100
        WORD    $0100, $0100, $0100, $0100, $5000, $5000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $5000, $5000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $5000, $5000, $0100, $0100

digit_5_pattern         ' Digit "5" - 0x6000
        WORD    $6000, $6000, $6000, $6000, $6000, $6000, $6000, $0100
        WORD    $6000, $6000, $0100, $0100, $0100, $0100, $0100, $0100
        WORD    $6000, $6000, $0100, $0100, $0100, $0100, $0100, $0100
        WORD    $6000, $6000, $6000, $6000, $6000, $6000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $6000, $6000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $6000, $6000, $0100
        WORD    $6000, $6000, $0100, $0100, $0100, $6000, $6000, $0100
        WORD    $0100, $6000, $6000, $6000, $6000, $6000, $0100, $0100

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
