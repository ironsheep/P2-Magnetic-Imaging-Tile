'' =================================================================================================
''   File....... isp_tile_sensor.spin2
''   Purpose.... Magnetic Imaging Tile sensor interface - Single COG architecture
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Nov 2025
''
''   Architecture: Single COG with inline PASM for sensor acquisition
''                Similar to isp_oled_single_cog.spin2 pattern
''
'' =================================================================================================

CON { tile sensor constants }

    ' Hardware pin group assignment (fixed for this project)
    TILE_PIN_GROUP  = 8                 ' Magnetic tile on P8-P15

    ' Pin assignments (relative to pin group)
    PIN_CS          = 0                 ' +0 - AD7680 Chip Select (VIOLET)
    PIN_CCLK        = 1                 ' +1 - Counter Clock (WHITE)
    PIN_MISO        = 2                 ' +2 - AD7680 Data Input (BLUE)
    PIN_CLRB        = 3                 ' +3 - Counter Clear (GRAY)
    PIN_SCLK        = 4                 ' +4 - AD7680 SPI Clock (GREEN)
    PIN_AOUT        = 6                 ' +6 - Analog Input (YELLOW)

    ' Absolute pin numbers (constants for fixed pin group)
    ABS_PIN_CS      = TILE_PIN_GROUP + PIN_CS
    ABS_PIN_CCLK    = TILE_PIN_GROUP + PIN_CCLK
    ABS_PIN_MISO    = TILE_PIN_GROUP + PIN_MISO
    ABS_PIN_CLRB    = TILE_PIN_GROUP + PIN_CLRB
    ABS_PIN_SCLK    = TILE_PIN_GROUP + PIN_SCLK
    ABS_PIN_AOUT    = TILE_PIN_GROUP + PIN_AOUT

    ' Pin field for all 5 control pins (11-bit encoded constant)
    CONTROL_PINS_FIELD = ABS_PIN_CS ADDPINS 4  ' CS through SCLK (5 pins total)

    ' Sensor array configuration
    SENSORS_PER_FRAME = 64              ' 8x8 sensor array
    SUBTILES = 4                        ' 4 quadrants
    SENSORS_PER_SUBTILE = 16            ' 4x4 per subtile

    ' ADC configuration - AD7680 (16-bit ADC, 24-bit SPI frame)
    ' Frame format: 4 leading zeros + 16-bit data + 4 trailing zeros = 24 bits total
    ADC_BITS = 16                       ' AD7680 is 16-bit ADC
    ADC_MAX_VALUE = (1 << ADC_BITS) - 1 ' Maximum ADC reading (65535)
    SPI_TRANSFER_BITS = 24              ' Total SPI transfer size (4 leading + 16 data + 4 trailing)

    ' Timing constants @ 250 MHz system clock (1 clock = 4ns)
    SENSOR_SETTLE_DELAY = 500           ' 2000ns (2µs) for analog settling - used for first sensor only
    COUNTER_SETUP_DELAY = 63            ' 250ns after counter operations
    RESIDUAL_SETTLE_DELAY = 200         ' 800ns additional settle after SPI completes (pipelined mode)
    FRAME_PERIOD_MS = 3                 ' ~333 fps target frame rate (@ 250 MHz)

    ' Smart Pin SPI configuration (P_PULSE mode like jm_ez_spi)
    SPI_CLOCK_FREQ = 2_500_000          ' 2.5 MHz SPI clock (AD7680 maximum)
    SPI_PERIOD = 250_000_000 / SPI_CLOCK_FREQ  ' Period in sysclks = 100 @ 250 MHz
    SPI_LOW_TIME = SPI_PERIOD / 2       ' 50% duty cycle = 50 sysclks

OBJ
    fifo : "isp_frame_fifo_manager"    ' Multi-FIFO frame pool manager (shared singleton)
    stack_check : "isp_stack_check"    ' Stack overflow detection utility

CON { stack configuration }

    SENSOR_STACK_SIZE_LONGS = 128       ' Stack size for sensor COG (increased from 64 - was causing overflow)

VAR { tile sensor variables }

    LONG    cog_id                      ' Sensor COG ID (-1 = stopped, >=0 = running)
    LONG    frame_count                 ' Total frames captured
    LONG    error_count                 ' SPI/sensor error count
    LONG    acquisition_mode            ' Current acquisition mode
    LONG    base_pin                    ' Base pin for sensor interface

    ' Baseline calibration
    WORD    baseline[SENSORS_PER_FRAME] ' Zero-field baseline values (64 sensors)
    LONG    baseline_valid              ' TRUE if baseline has been calibrated

    ' Test pattern state
    LONG    test_frame_counter          ' Test mode: current frame index (0-5)

CON { acquisition modes }

    #0                              ' Start enumeration at 0
    MODE_STOPPED                    ' = 0
    MODE_LIVE                       ' = 1
    MODE_HIGH_SPEED                 ' = 2
    MODE_DEBUG                      ' = 3
    MODE_TEST_PATTERN               ' = 4
    MODE_ADC_VERIFY                 ' = 5 - Two scans with full logging for logic analyzer comparison

DAT { sensor COG stack with overflow detection }

    ' Stack for sensor COG - placed in DAT with sentinel mark for overflow detection
    sensor_cog_stack    LONG    0[SENSOR_STACK_SIZE_LONGS]
    sensor_stack_mark   LONG    stack_check.DO_NOT_WRITE_MARK   ' Sentinel - overflow if overwritten

DAT { sensor mapping arrays }

'------------------------------------------------------------------------------
    ' UNIFIED SENSOR MAPPING TABLE - v3 VERIFIED (2025-12-23)
    '------------------------------------------------------------------------------
    ' Single 64-entry lookup table: Hardware counter (0-63) → Buffer position (0-63)
    '
    ' EN→QUADRANT MAPPING:
    '   EN1 (counter 0-15)  → Physical LL quadrant → Buffer rows 4-7, cols 0-3
    '   EN2 (counter 16-31) → Physical LR quadrant → Buffer rows 4-7, cols 4-7
    '   EN3 (counter 32-47) → Physical UL quadrant → Buffer rows 0-3, cols 0-3
    '   EN4 (counter 48-63) → Physical UR quadrant → Buffer rows 0-3, cols 4-7
    '
    ' WITHIN-QUADRANT CHANNEL LAYOUT:
    '         Col0    Col1    Col2    Col3
    '   Row0  Ch4     Ch6     Ch0     Ch2     (TL corner = Ch4-7)
    '   Row1  Ch5     Ch7     Ch1     Ch3     (TR corner = Ch0-3)
    '   Row2  Ch8     Ch10    Ch12    Ch14    (BL corner = Ch8-11)
    '   Row3  Ch9     Ch11    Ch13    Ch15    (BR corner = Ch12-15)
    '
    ' VERIFICATION (quadrant center test 2025-12-23):
    '   Physical UL center → Buffer centroid (1.5, 1.7) - UL quadrant ✓
    '   Physical UR center → Buffer centroid (1.6, 5.5) - UR quadrant ✓
    '   Physical LR center → Buffer centroid (5.6, 5.4) - LR quadrant ✓
    '   Physical LL center → Buffer centroid (5.6, 1.2) - LL quadrant ✓
    '------------------------------------------------------------------------------
    unified_sensor_map  BYTE    34, 42, 35, 43, 32, 40, 33, 41    ' Counter 0-7   (EN1 → LL)
                        BYTE    48, 56, 49, 57, 50, 58, 51, 59    ' Counter 8-15  (EN1 → LL)
                        BYTE    38, 46, 39, 47, 36, 44, 37, 45    ' Counter 16-23 (EN2 → LR)
                        BYTE    52, 60, 53, 61, 54, 62, 55, 63    ' Counter 24-31 (EN2 → LR)
                        BYTE     2, 10,  3, 11,  0,  8,  1,  9    ' Counter 32-39 (EN3 → UL)
                        BYTE    16, 24, 17, 25, 18, 26, 19, 27    ' Counter 40-47 (EN3 → UL)
                        BYTE     6, 14,  7, 15,  4, 12,  5, 13    ' Counter 48-55 (EN4 → UR)
                        BYTE    20, 28, 21, 29, 22, 30, 23, 31    ' Counter 56-63 (EN4 → UR)

PUB null()
'' This is not a top-level object
'' @returns nothing - placeholder method for non-top-level object
    cog_id := -1

PUB start(sensor_base_pin) : success
'' Start the tile sensor single-COG driver
'' @param sensor_base_pin - base pin for sensor interface
'' @returns TRUE if successful, FALSE if failed to start

    ' Initialize COG ID FIRST (critical - must be set before any checks!)
    if cog_id == 0
        cog_id := -1

    if cog_id >= 0
        return TRUE                     ' Already running

    ' Save pin configuration
    base_pin := sensor_base_pin

    ' Initialize variables
    frame_count := 0
    error_count := 0
    acquisition_mode := MODE_LIVE       ' Start in live mode
    baseline_valid := FALSE             ' No baseline until calibrated
    test_frame_counter := 0

    ' Prepare stack for overflow detection
    stack_check.prepStackForCheck(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)

    ' Launch sensor COG
    debug("Sensor: Launching single-COG driver...", 13, 10)
    cog_id := cogspin(NEWCOG, sensor_loop(), @sensor_cog_stack)

    if cog_id < 0
        debug("Sensor: ERROR - COG launch failed!", 13, 10)
        return FALSE

    debug("Sensor: COG ", udec(cog_id), " launched successfully", 13, 10)
    return TRUE

PUB stop()
'' Stop the tile sensor and terminate COG operation

    if cog_id >= 0 and cog_id <= 7
        cogstop(cog_id)
    cog_id := -1

PUB set_acquisition_mode(mode)
'' Set the sensor acquisition mode
'' @param mode - acquisition mode: MODE_STOPPED, MODE_LIVE, MODE_TEST_PATTERN, etc.

    acquisition_mode := mode

PUB get_frame_count() : count
'' Get total number of frames captured since start
'' @returns total frame count as LONG

    return frame_count

PUB get_error_count() : count
'' Get total number of SPI/sensor errors encountered
'' @returns error count as LONG

    return error_count

PUB is_running() : state
'' Check if sensor background cog is currently running
'' @returns TRUE if running, FALSE if stopped

    return (cog_id >= 0)

PUB reset_counter_test()
'' TEST METHOD: Reset hardware counter to sensor 0
'' Pulses CLRb low to reset multiplexer counter
'' @note For regression testing only - validates counter control

    debug("TEST: reset_counter_test() called", 13, 10)
    org
        drvl    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY
        drvh    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY
    end
    debug("TEST: reset_counter_test() completed", 13, 10)

PUB advance_counter_test()
'' TEST METHOD: Advance hardware counter to next sensor
'' Pulses CCLK high to increment multiplexer counter
'' @note For regression testing only - validates counter control

    org
        drvl    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
    end

PUB read_single_sensor() : sensor_value | raw_value, event_config
'' TEST METHOD: Read current sensor using smart pin SPI interface
'' Uses P_PULSE clock mode for reliable operation
'' OPTIMIZED (Nov 2025): No per-transfer reset, uses waitse1 instead of polling
'' @returns 16-bit sensor value (0-65535)
'' @note For regression testing only - tests smart pin sync RX/clock generation
'' @note configure_smart_pins() must be called first!

    ' Build event configuration (needed for inline PASM in Spin2 context)
    event_config := %01_000000 | ABS_PIN_SCLK

    org
        ' Configure event for this read (Spin2 inline PASM doesn't share COG's setse1)
        setse1  event_config

        ' Start ADC conversion (CS low - captures analog value)
        drvl    #ABS_PIN_CS
        waitx   #SENSOR_SETTLE_DELAY

        ' Trigger SPI clock pulses (P_PULSE mode: wypin = number of pulses = bits)
        wypin   #SPI_TRANSFER_BITS, #ABS_PIN_SCLK    ' Generate 24 clock pulses
        akpin   #ABS_PIN_SCLK                        ' Clear any stale IN flag
        waitse1                                      ' Wait efficiently for completion

        ' Clock finished - read received data from MISO
        rdpin   raw_value, #ABS_PIN_MISO             ' Read 16-bit value (left-justified, LSB-first)

        ' End conversion (CS high)
        drvh    #ABS_PIN_CS

        ' Process data: AD7940 sends MSB-first, but P_SYNC_RX receives LSB-first
        ' After REV, the 16-bit frame is in Z[15:0] (right-justified)
        ' AD7940 frame: 1 leading zero + 14-bit data + 1 trailing zero
        ' After REV: Z[15]=trailing, Z[14:1]=data, Z[0]=leading
        rev     raw_value                            ' Reverse all 32 bits (MSB-first now, right-justified)
        shr     raw_value, #1                        ' Shift out 1 trailing zero
        and     raw_value, ##$3FFF                   ' Mask to 14 bits
        mov     sensor_value, raw_value
    end

PUB configure_smart_pins() | sclk_x, event_config
'' Configure smart pins for SPI communication with AD7680
'' Uses P_PULSE mode for clock (like jm_ez_spi) - more reliable than P_TRANSITION
'' Called ONCE before using test methods or by sensor COG at startup
'' @note Public to allow test code to configure pins explicitly
''
'' OPTIMIZATION (Nov 2025): Smart pins are configured ONCE here and maintain
'' their settings across transfers. No need to reset/reconfigure per-transfer.
'' Also configures event SE1 for efficient waitse1-based waiting.

    debug("Sensor: Configuring smart pins for SPI (P_PULSE mode + events)...", 13, 10)

    ' Build SCLK X register: X[15:0]=period, X[31:16]=low_time
    sclk_x := SPI_PERIOD | (SPI_LOW_TIME << 16)

    ' Build event configuration: %01 = positive edge, pin number in lower 6 bits
    event_config := %01_000000 | ABS_PIN_SCLK

    org
        ' Configure SCLK (P12) as pulse output (SPI clock generator)
        ' P_PULSE mode: wypin sets pulse count, pin generates that many clock cycles
        dirl    #ABS_PIN_SCLK                        ' Clear/reset smart pin
        wrpin   ##P_PULSE | P_OE, #ABS_PIN_SCLK      ' Pulse mode for clock generation
        wxpin   sclk_x, #ABS_PIN_SCLK                ' X[15:0]=period, X[31:16]=low_time
        dirh    #ABS_PIN_SCLK                        ' Enable smart pin

        ' Configure MISO (P10) as sync serial RX (data receiver)
        ' SCLK is 2 pins away (P12), so use P_PLUS2_B to specify B-input source
        ' P_INVERT_B: AD7680 outputs data on FALLING edge, so invert clock sense
        ' OPTIMIZATION: Configure ONCE and leave enabled - no per-transfer reset needed
        dirl    #ABS_PIN_MISO                        ' Clear/reset smart pin
        wrpin   ##P_SYNC_RX | P_PLUS2_B | P_INVERT_B, #ABS_PIN_MISO ' Sync RX, clock from pin+2, sample on falling edge
        wxpin   #%0_10111, #ABS_PIN_MISO             ' Pre-edge sample, 24 bits (bit_count-1 = 23)
        dirh    #ABS_PIN_MISO                        ' Enable MISO - stays enabled!

        ' Configure event SE1 for SCLK completion (positive edge on IN flag)
        ' This enables efficient waitse1 instead of polling loop
        setse1  event_config

        ' Configure CS, CCLK, CLRb as normal digital outputs with initial states
        drvh    #ABS_PIN_CS                          ' CS high (inactive)
        drvl    #ABS_PIN_CCLK                        ' CCLK low
        drvh    #ABS_PIN_CLRB                        ' CLRb high (not clearing)
    end

    debug("Sensor: Smart pins configured (MISO stays enabled, SE1 event ready)", 13, 10)

PRI sensor_loop() | framePtr, patternPtr, sensor_idx, sensor_val
'' Main sensor loop running in dedicated COG
'' Handles both test pattern generation and live sensor acquisition

    debug("Sensor: COG loop started", 13, 10)

    ' CRITICAL: Show stack address to diagnose memory corruption
    debug("SENSOR STACK: ", uhex_long(@sensor_cog_stack), " to ", uhex_long(@sensor_cog_stack + (SENSOR_STACK_SIZE_LONGS * 4) - 1), 13, 10)

    ' Configure smart pins for SPI (ONCE at startup)
    stack_check.checkStack(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)
    configure_smart_pins()
    stack_check.checkStack(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)

    repeat
        ' Check for stack overflow (halts with debug message if detected)
        stack_check.checkStack(@sensor_cog_stack, SENSOR_STACK_SIZE_LONGS)

        ' Check acquisition mode
        case acquisition_mode
            MODE_STOPPED:
                waitms(10)
                next

            MODE_TEST_PATTERN:
                ' Generate test patterns (Spin2)
                generate_test_frame()

            MODE_LIVE:
                ' Acquire live sensor data
                acquire_sensor_frame()

            MODE_ADC_VERIFY:
                ' ADC verification mode: 2 scans with full logging, then stop
                adc_verify_scan()
                acquisition_mode := MODE_STOPPED  ' Auto-stop after verification

            OTHER:
                waitms(10)

PRI generate_test_frame() | framePtr, patternPtr
'' Generate test pattern frame (digits 0-5)

    ' Get frame buffer from FIFO
    framePtr := fifo.getNextFrame()
    if framePtr == 0
        waitms(1)
        return

    ' Select pattern based on counter
    case test_frame_counter
        0: patternPtr := @digit_0_pattern
        1: patternPtr := @digit_1_pattern
        2: patternPtr := @digit_2_pattern
        3: patternPtr := @digit_3_pattern
        4: patternPtr := @digit_4_pattern
        5: patternPtr := @digit_5_pattern

    ' Copy pattern to frame buffer (64 WORDs = 128 bytes)
    WORDMOVE(framePtr, patternPtr, 64)

    ' Commit frame to sensor FIFO
    if fifo.commitFrame(fifo.FIFO_SENSOR, framePtr) < 0
        fifo.releaseFrame(framePtr)
    else
        frame_count++

    ' Increment test counter
    test_frame_counter++
    if test_frame_counter >= 6
        test_frame_counter := 0
        waitms(1000)  ' 1 second between test pattern cycles
    else
        waitms(100)   ' 100ms between individual patterns

PRI acquire_sensor_frame() | framePtr, sensor_val, buf_ptr, total_sensor_count, lut_unified
'' Acquire live sensor frame using inline PASM for timing-critical operations
'' OPTIMIZED (Nov 2025): Pipelined counter advance during SPI transfer
'' SIMPLIFIED (Dec 2025): Single unified lookup table replaces 4 separate tables
''
'' Pipeline strategy:
''   - First sensor: Full settle wait, then start SPI
''   - During SPI: Advance counter to NEXT sensor (overlaps with SPI time)
''   - After SPI: Small residual settle, read data, store
''   - Subsequent sensors: Already settled from previous iteration
''
'' This hides ~2.75µs of counter/settle time inside the 9.6µs SPI transfer

    ' Get frame buffer from FIFO
    framePtr := fifo.getNextFrame()
    debug("SENSOR: GET ptr=", uhex_long(framePtr), 13, 10)
    if framePtr == 0
        waitms(1)
        return

    ' CRITICAL: Pre-load unified lookup table address BEFORE inline PASM
    ' This avoids modifying ptra inside PASM which corrupts stack access
    lut_unified := @unified_sensor_map

    ' Use inline PASM to read all 64 sensors with pipelined counter advance
    ' NOTE: We use pa, pb for temporary pointers instead of ptra to avoid
    ' corrupting Spin2's stack pointer
    ORG
        ' Jump to main code (subroutines placed first for backward reference only)
        jmp     #.main_start

' ============================================
' Subroutines (placed first so all calls are backward references)
' ============================================

'------------------------------------------------------------------------------
' store_sensor_value: Store ADC reading at mapped buffer location
'------------------------------------------------------------------------------
' UNIFIED MAPPING: counter index → final buffer position (single lookup)
'
' The unified_sensor_map table combines all transformations:
'   - EN signal → physical quadrant mapping (from empirical testing)
'   - Channel → position within quadrant (from schematic)
'   - Physical position = buffer position (1:1 mapping goal)
'
' Inputs:
'   total_sensor_count - Current counter index (0-63)
'   sensor_val         - ADC value to store
'   framePtr           - Base address of frame buffer
'   lut_unified        - Unified lookup table address (pre-loaded in Spin2)
'
' Uses pa as temp pointer (NOT ptra - that breaks Spin2 stack access!)
' Modifies: pa, buf_ptr
'------------------------------------------------------------------------------
.store_sensor_value
        '======================================================================
        ' UNIFIED MAPPING: Counter index → Buffer position (single lookup)
        '======================================================================
        mov     pa, lut_unified
        add     pa, total_sensor_count
        rdbyte  buf_ptr, pa

        '======================================================================
        ' Calculate byte address and store
        '======================================================================
        shl     buf_ptr, #1                    ' Convert to byte offset (* 2 for WORD)
        add     buf_ptr, framePtr              ' Add frame base address

        ' Store value in frame buffer at mapped position
        wrword  sensor_val, buf_ptr
        ret

' ============================================
' Main acquisition code
' ============================================
.main_start
        ' framePtr already contains the frame buffer address from Spin2

        ' Reset sensor counter to position 0
        drvl    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY
        drvh    #ABS_PIN_CLRB
        waitx   #COUNTER_SETUP_DELAY

        ' Advance to sensor 1 (first active sensor per documentation)
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY

        ' Initialize total sensor counter (0-63)
        mov     total_sensor_count, #0

        ' ========== FIRST SENSOR: Full settle required ==========
        ' CS low to capture analog value
        drvl    #ABS_PIN_CS
        waitx   #SENSOR_SETTLE_DELAY              ' Full settle for first sensor

        ' Start SPI transfer for sensor 0
        wypin   #SPI_TRANSFER_BITS, #ABS_PIN_SCLK
        akpin   #ABS_PIN_SCLK

        ' WHILE SPI RUNS: Advance counter to sensor 1
        ' (sensor 1 starts settling now, will be ready by next read)
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        ' Mux now switching to sensor 1, settling begins

        ' Wait for SPI to complete
        waitse1

        ' Read and process sensor 0 data (AD7680: 4 leading + 16 data + 4 trailing)
        rdpin   sensor_val, #ABS_PIN_MISO
        drvh    #ABS_PIN_CS
        rev     sensor_val
        shr     sensor_val, #4              ' Shift out 4 trailing zeros
        and     sensor_val, ##$FFFF         ' Mask to 16 bits

        ' Store sensor 0 using unified mapping lookup
        call    #.store_sensor_value

        ' Increment counter
        add     total_sensor_count, #1

        ' ========== SENSORS 1-62: Pipelined (already settling) ==========
.pipelined_loop
        ' Residual settle time (sensor was advancing during previous SPI)
        waitx   #RESIDUAL_SETTLE_DELAY

        ' CS low - analog value already stable
        drvl    #ABS_PIN_CS

        ' Start SPI transfer for current sensor
        wypin   #SPI_TRANSFER_BITS, #ABS_PIN_SCLK
        akpin   #ABS_PIN_SCLK

        ' Check if this is the last sensor (>= 63, defensive)
        cmp     total_sensor_count, #63 wcz
  if_ae jmp     #.last_sensor

        ' WHILE SPI RUNS: Advance counter to NEXT sensor
        drvh    #ABS_PIN_CCLK
        waitx   #COUNTER_SETUP_DELAY
        drvl    #ABS_PIN_CCLK
        ' Next sensor now settling...

        ' Wait for SPI to complete
        waitse1

        ' Read and process current sensor data (AD7680: 4 leading + 16 data + 4 trailing)
        rdpin   sensor_val, #ABS_PIN_MISO
        drvh    #ABS_PIN_CS
        rev     sensor_val
        shr     sensor_val, #4              ' Shift out 4 trailing zeros
        and     sensor_val, ##$FFFF         ' Mask to 16 bits

        ' Store using unified mapping lookup
        call    #.store_sensor_value

        ' Increment counter and loop
        add     total_sensor_count, #1
        jmp     #.pipelined_loop

        ' ========== LAST SENSOR (63): No counter advance needed ==========
.last_sensor
        ' Wait for SPI to complete (no counter advance - we're done)
        waitse1

        ' Read and process final sensor data (AD7680: 4 leading + 16 data + 4 trailing)
        rdpin   sensor_val, #ABS_PIN_MISO
        drvh    #ABS_PIN_CS
        rev     sensor_val
        shr     sensor_val, #4              ' Shift out 4 trailing zeros
        and     sensor_val, ##$FFFF         ' Mask to 16 bits

        ' Store final sensor
        call    #.store_sensor_value

        ' Frame acquisition complete
        ' NOTE: We no longer need to restore ptra because we never modified it!
        ' Using pa instead of ptra for lookup pointers preserves Spin2 stack access

    END

    ' Commit completed frame to sensor FIFO
    debug("SENSOR: COMMIT ptr=", uhex_long(framePtr), 13, 10)
    if fifo.commitFrame(fifo.FIFO_SENSOR, framePtr) < 0
        ' FIFO full - release frame back to pool
        debug("SENSOR: RELEASE (full) ptr=", uhex_long(framePtr), 13, 10)
        fifo.releaseFrame(framePtr)
    else
        ' Frame committed successfully
        frame_count++

    ' Minimal delay - decimator debug removed so it can keep up
    waitus(10)                          ' 10 us gap - ~1,370 fps max

PRI adc_verify_scan() | scan_num, sensor_num, raw_value, processed_value, event_config
'' ADC Verification Mode: Perform exactly 2 full scans with detailed logging
'' Reads all 64 sensors twice, logging raw and processed values for each
'' Used to compare against logic analyzer captures for bit extraction validation
''
'' Output format per sensor:
''   "VERIFY: Scan N Sensor NN: raw=XXXX proc=DDDD"
'' Where:
''   N = scan number (1 or 2)
''   NN = sensor number (0-63, in hardware read order)
''   XXXX = raw 16-bit value from SPI (before processing)
''   DDDD = processed 14-bit value (after REV, shift, mask)

  debug("=== ADC VERIFY MODE START ===", 13, 10)
  debug("Performing 2 scans of 64 sensors each", 13, 10)
  debug("Compare these values with logic analyzer capture", 13, 10)
  debug(" ", 13, 10)

  ' Build event configuration for waitse1
  event_config := %01_000000 | ABS_PIN_SCLK

  repeat scan_num from 1 to 2
    debug("--- SCAN ", udec(scan_num), " ---", 13, 10)

    ' Reset counter to sensor 0
    org
      drvl    #ABS_PIN_CLRB
      waitx   #COUNTER_SETUP_DELAY
      drvh    #ABS_PIN_CLRB
      waitx   #COUNTER_SETUP_DELAY
    end

    ' Advance to sensor 1 (first active sensor)
    org
      drvh    #ABS_PIN_CCLK
      waitx   #COUNTER_SETUP_DELAY
      drvl    #ABS_PIN_CCLK
      waitx   #COUNTER_SETUP_DELAY
    end

    ' Read all 64 sensors
    repeat sensor_num from 0 to 63
      ' Configure event for this read
      org
        setse1  event_config
      end

      ' Start ADC conversion (CS low)
      org
        drvl    #ABS_PIN_CS
        waitx   #SENSOR_SETTLE_DELAY
      end

      ' Trigger SPI clock pulses and wait for completion
      org
        wypin   #SPI_TRANSFER_BITS, #ABS_PIN_SCLK
        akpin   #ABS_PIN_SCLK
        waitse1
      end

      ' Read raw value from MISO
      org
        rdpin   raw_value, #ABS_PIN_MISO
        drvh    #ABS_PIN_CS
      end

      ' Process the raw value (same logic as acquire_sensor_frame)
      ' AD7680: MSB-first, but P_SYNC_RX receives LSB-first
      ' After rdpin, data is left-justified in 32-bit register
      ' REV reverses all 32 bits, then we extract the 16-bit value
      ' Frame: 4 leading zeros + 16 data bits + 4 trailing zeros
      processed_value := raw_value
      org
        rev     processed_value
        shr     processed_value, #4          ' Shift out 4 trailing zeros
        and     processed_value, ##$FFFF     ' Mask to 16 bits
      end

      ' Log both raw and processed values
      debug("VERIFY: S", udec(scan_num), " Sensor ", udec_(sensor_num), ": raw=", uhex_(raw_value), " proc=", udec_(processed_value), 13, 10)

      ' Advance counter to next sensor (except after last sensor)
      if sensor_num < 63
        org
          drvh    #ABS_PIN_CCLK
          waitx   #COUNTER_SETUP_DELAY
          drvl    #ABS_PIN_CCLK
          waitx   #COUNTER_SETUP_DELAY
        end

    debug(" ", 13, 10)

  debug("=== ADC VERIFY MODE COMPLETE ===", 13, 10)
  debug("Sensor driver now STOPPED", 13, 10)

DAT { test pattern digit data - 8x8 WORD arrays in HUB memory }

' Each digit is 64 WORDs (128 bytes) representing an 8x8 grid
' Background: $0100, Digit pixels use unique values for color differentiation

digit_0_pattern         ' Digit "0" - 0x1000
        WORD    $0100, $1000, $1000, $1000, $1000, $1000, $1000, $0100
        WORD    $1000, $1000, $0100, $0100, $0100, $0100, $1000, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $0100, $0100, $0100, $0100, $0100, $0100, $1000
        WORD    $1000, $1000, $0100, $0100, $0100, $0100, $1000, $1000
        WORD    $0100, $1000, $1000, $1000, $1000, $1000, $1000, $0100

digit_1_pattern         ' Digit "1" - 0x2000
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $2000, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100
        WORD    $0100, $0100, $0100, $2000, $2000, $0100, $0100, $0100

digit_2_pattern         ' Digit "2" - 0x3000
        WORD    $0100, $3000, $3000, $3000, $3000, $3000, $0100, $0100
        WORD    $3000, $3000, $0100, $0100, $0100, $3000, $3000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $3000, $3000, $0100
        WORD    $0100, $0100, $0100, $0100, $3000, $3000, $0100, $0100
        WORD    $0100, $0100, $0100, $3000, $3000, $0100, $0100, $0100
        WORD    $0100, $0100, $3000, $3000, $0100, $0100, $0100, $0100
        WORD    $0100, $3000, $3000, $0100, $0100, $0100, $0100, $0100
        WORD    $3000, $3000, $3000, $3000, $3000, $3000, $3000, $0100

digit_3_pattern         ' Digit "3" - 0x4000
        WORD    $0100, $4000, $4000, $4000, $4000, $4000, $0100, $0100
        WORD    $4000, $4000, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $0100, $4000, $4000, $4000, $4000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $4000, $4000, $0100, $0100, $0100, $4000, $4000, $0100
        WORD    $0100, $4000, $4000, $4000, $4000, $4000, $0100, $0100

digit_4_pattern         ' Digit "4" - 0x5000
        WORD    $0100, $0100, $0100, $5000, $5000, $5000, $0100, $0100
        WORD    $0100, $0100, $5000, $5000, $5000, $5000, $0100, $0100
        WORD    $0100, $5000, $5000, $0100, $5000, $5000, $0100, $0100
        WORD    $5000, $5000, $0100, $0100, $5000, $5000, $0100, $0100
        WORD    $5000, $5000, $5000, $5000, $5000, $5000, $5000, $0100
        WORD    $0100, $0100, $0100, $0100, $5000, $5000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $5000, $5000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $5000, $5000, $0100, $0100

digit_5_pattern         ' Digit "5" - 0x6000
        WORD    $6000, $6000, $6000, $6000, $6000, $6000, $6000, $0100
        WORD    $6000, $6000, $0100, $0100, $0100, $0100, $0100, $0100
        WORD    $6000, $6000, $0100, $0100, $0100, $0100, $0100, $0100
        WORD    $6000, $6000, $6000, $6000, $6000, $6000, $0100, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $6000, $6000, $0100
        WORD    $0100, $0100, $0100, $0100, $0100, $6000, $6000, $0100
        WORD    $6000, $6000, $0100, $0100, $0100, $6000, $6000, $0100
        WORD    $0100, $6000, $6000, $6000, $6000, $6000, $0100, $0100

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
