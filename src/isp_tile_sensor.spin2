'' =================================================================================================
''   File....... isp_tile_sensor.spin2
''   Purpose.... Magnetic Imaging Tile sensor interface with new FIFO architecture
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Jan 2025
''
'' =================================================================================================

CON { tile sensor constants }

    ' Hardware pin group assignment (fixed for this project)
    TILE_PIN_GROUP  = 8                 ' Magnetic tile on P8-P15

    ' Pin assignments (relative to pin group)
    PIN_CS          = 0                 ' +0 - AD7680 Chip Select (VIOLET)
    PIN_CCLK        = 1                 ' +1 - Counter Clock (WHITE)
    PIN_MISO        = 2                 ' +2 - AD7680 Data Input (BLUE)
    PIN_CLRB        = 3                 ' +3 - Counter Clear (GRAY)
    PIN_SCLK        = 4                 ' +4 - AD7680 SPI Clock (GREEN)
    PIN_AOUT        = 6                 ' +6 - Analog Input (YELLOW)

    ' Absolute pin numbers (constants for fixed pin group)
    ABS_PIN_CS      = TILE_PIN_GROUP + PIN_CS
    ABS_PIN_CCLK    = TILE_PIN_GROUP + PIN_CCLK
    ABS_PIN_MISO    = TILE_PIN_GROUP + PIN_MISO
    ABS_PIN_CLRB    = TILE_PIN_GROUP + PIN_CLRB
    ABS_PIN_SCLK    = TILE_PIN_GROUP + PIN_SCLK
    ABS_PIN_AOUT    = TILE_PIN_GROUP + PIN_AOUT

    ' Pin field for all 5 control pins (11-bit encoded constant)
    CONTROL_PINS_FIELD = ABS_PIN_CS ADDPINS 4  ' CS through SCLK (5 pins total)

    ' Sensor array configuration
    SENSORS_PER_FRAME = 64              ' 8x8 sensor array
    SUBTILES = 4                        ' 4 quadrants
    SENSORS_PER_SUBTILE = 16            ' 4x4 per subtile

    ' ADC configuration
    ADC_BITS = 16                       ' AD7680 is 16-bit ADC
    ADC_MAX_VALUE = (1 << ADC_BITS) - 1 ' Maximum ADC reading
    SPI_TRANSFER_BITS = 24              ' Total SPI transfer size (4 leading + 16 data + 4 trailing)
    SPI_DATA_BITS = 20                  ' Minimum transfer (4 leading + 16 data)

    ' Timing constants (in system clocks @ 200 MHz sysclock, 1 clock = 5ns)
    SPI_CLOCK_DELAY = 40                ' 200ns per SPI clock edge (for 2.5 MHz = 400ns period)
    COUNTER_SETUP_DELAY = 50            ' 250ns after counter operations (OK)
    SENSOR_SETTLE_DELAY = 400           ' 2000ns (2µs) for analog settling - CRITICAL!
    ADC_CONVERSION_CLOCKS = 1600        ' 8000ns (8µs) for 20 SPI clocks @ 2.5 MHz

    ' Smart Pin SPI configuration (if used - bit-bang is more reliable)
    SPI_CLOCK_FREQ = 2_500_000          ' 2.5 MHz SPI clock (AD7680 maximum)

    ' Note: P_SYNC_RX, P_SYNC_TX and other smart pin constants are built-in

    ' Subtile reading order (based on hardware layout)
    ' Documentation specifies: subtileOrder[] = {0, 2, 1, 3}
    ' subtileOffset[] = {0, 4, 32, 36}

OBJ
    fifo : "isp_frame_fifo_manager"    ' Multi-FIFO frame pool manager

VAR { tile sensor variables }

    LONG    cog_id                      ' PASM acquisition COG ID (-1 = stopped, >=0 = running)
    LONG    manager_cog_id              ' Spin2 FIFO manager COG ID
    LONG    frame_count                 ' Total frames captured
    LONG    error_count                 ' SPI/sensor error count
    LONG    acquisition_mode            ' Current acquisition mode
    LONG    frame_rate_target           ' Target frame rate (Hz)

    ' Performance monitoring
    LONG    last_frame_time             ' Timestamp of last frame
    LONG    min_frame_time              ' Minimum time between frames
    LONG    max_frame_time              ' Maximum time between frames

    ' Baseline calibration
    WORD    baseline[SENSORS_PER_FRAME] ' Zero-field baseline values (64 sensors)
    LONG    baseline_valid              ' TRUE if baseline has been calibrated
    LONG    base_pin                    ' Base pin for sensor interface

    ' Test pattern state
    LONG    test_pattern_frame_num      ' Current test pattern frame (0-4)

    ' Mailbox for Spin2 <-> PASM communication
    LONG    mailbox_frame_ptr           ' Frame buffer pointer (Spin2 provides, PASM writes to)
    LONG    mailbox_go_flag             ' Handshake: 1=PASM capture, 0=PASM done

CON { acquisition modes }

    #0                              ' Start enumeration at 0
    MODE_STOPPED                    ' = 0
    MODE_LIVE                       ' = 1
    MODE_HIGH_SPEED                 ' = 2
    MODE_DEBUG                      ' = 3
    MODE_TEST_PATTERN               ' = 4

DAT { sensor mapping arrays }

    ' Subtile reading order: scan subtiles 0, 2, 1, 3 (not sequential!)
    subtile_order   BYTE    0, 2, 1, 3

    ' Frame buffer offsets for each subtile (words)
    subtile_offset  BYTE    0, 4, 32, 36

    ' Pixel mapping within each subtile (serpentine pattern)
    ' Maps counter position (0-15) to frame buffer position within subtile
    pixel_order     BYTE    26, 27, 18, 19, 10, 11, 2, 3
                    BYTE    1, 0, 9, 8, 17, 16, 25, 24

PUB null()
'' This is not a top-level object
'' @returns nothing - placeholder method for non-top-level object
    cog_id := -1                        ' Initialize to stopped state

PUB start(sensor_base_pin) : success
'' Start the tile sensor and begin background acquisition
'' @param sensor_base_pin - base pin for sensor interface
'' @returns TRUE if successful, FALSE if failed to start

    ' Initialize COG IDs FIRST (critical - must be set before any checks!)
    if cog_id == 0
        cog_id := -1
        manager_cog_id := -1

    if cog_id >= 0
        return TRUE                     ' Already running

    ' Save pin configuration
    base_pin := sensor_base_pin

    ' Initialize variables
    frame_count := 0
    error_count := 0
    acquisition_mode := MODE_TEST_PATTERN  ' Start in test mode so FIFO manager runs
    frame_rate_target := 375            ' Default 375 Hz (1/4 max speed)
    min_frame_time := $7FFFFFFF
    max_frame_time := 0
    baseline_valid := FALSE             ' No baseline until calibrated

    ' Initialize mailbox
    mailbox_frame_ptr := 0
    mailbox_go_flag := 0

    ' Start Spin2 FIFO manager COG (manages FIFO operations)
    debug("Sensor: Launching FIFO manager COG...", 13, 10)
    manager_cog_id := cogspin(NEWCOG, fifo_manager_loop(), 0)
    if manager_cog_id < 0
        debug("Sensor: ERROR - FIFO manager COG failed!", 13, 10)
        return FALSE
    debug("Sensor: FIFO manager COG ", udec(manager_cog_id), " launched", 13, 10)

    ' Start PASM acquisition COG (reads sensors, writes to buffers)
    debug("Sensor: Launching PASM acquisition COG...", 13, 10)
    cog_id := coginit(NEWCOG, @sensor_cog_entry, @frame_count)
    if cog_id < 0
        debug("Sensor: ERROR - PASM acquisition COG failed!", 13, 10)
        cogstop(manager_cog_id)
        return FALSE
    debug("Sensor: PASM acquisition COG ", udec(cog_id), " launched", 13, 10)

    ' Return success based on cog_id validity
    return (cog_id >= 0)

PUB stop()
'' Stop the tile sensor and terminate background cog operation
'' @returns nothing - stops all sensor operations

    if cog_id >= 0 and cog_id <= 7
        cogstop(cog_id)
        cog_id := -1

    if manager_cog_id >= 0 and manager_cog_id <= 7
        cogstop(manager_cog_id)
        manager_cog_id := -1

PUB set_acquisition_mode(mode)
'' Set the sensor acquisition mode for different capture speeds
'' @param mode - acquisition mode: MODE_STOPPED (0), MODE_LIVE (1), MODE_HIGH_SPEED (2), or MODE_DEBUG (3)
'' @returns nothing - updates internal acquisition state

    acquisition_mode := mode

PUB set_frame_rate_target(rate_hz)
'' Set target frame rate for acquisition timing control
'' @param rate_hz - target frame rate in Hz (valid range: 1-2000)
'' @returns nothing - updates frame rate if within valid range

    if rate_hz >= 1 and rate_hz <= 2000
        frame_rate_target := rate_hz

PUB get_frame_count() : count
'' Get total number of frames captured since start
'' @returns total frame count as LONG

    return frame_count

PUB get_error_count() : count
'' Get total number of SPI/sensor errors encountered
'' @returns error count as LONG

    return error_count

PUB get_performance_stats(stats_ptr)
'' Get comprehensive performance statistics from sensor system
'' @param stats_ptr - pointer to LONG array[5] to receive stats: [0]=total frames, [1]=errors, [2]=frame rate (Hz), [3]=min frame time, [4]=max frame time
'' @returns nothing - fills provided array with statistics

    if stats_ptr == 0
        return

    LONG[stats_ptr][0] := frame_count
    LONG[stats_ptr][1] := error_count

    ' Calculate current frame rate estimate
    if min_frame_time > 0
        LONG[stats_ptr][2] := clkfreq / min_frame_time
    else
        LONG[stats_ptr][2] := 0

    LONG[stats_ptr][3] := min_frame_time
    LONG[stats_ptr][4] := max_frame_time

PUB is_running() : state
'' Check if sensor background cog is currently running
'' @returns TRUE if running, FALSE if stopped

    return (cog_id >= 0)

PUB calibrate_baseline() : success | i
'' Capture current sensor readings as zero-field baseline
'' @returns TRUE if successful, FALSE if failed
'' NOTE: Should be called with no magnetic field present

    ' Temporarily stop acquisition
    acquisition_mode := MODE_STOPPED
    WAITMS(10)                          ' Wait for current frame to complete

    ' Read all sensors to establish baseline
    reset_counter_test()
    advance_counter_test()

    repeat i from 0 to 63
        baseline[i] := read_single_sensor_bitbang()
        if i < 63
            advance_counter_test()

    ' Mark baseline as valid
    baseline_valid := TRUE

    debug("Baseline calibration complete")
    debug("  Baseline range: ", udec(WORD[@baseline][0]), " to ", udec(WORD[@baseline][63]))

    return TRUE

PUB get_frame_position(subtile, sensor_pos) : frame_pos
'' Calculate frame buffer position for given subtile and sensor using hardware mapping
'' @param subtile - subtile number (0-3) representing quadrant
'' @param sensor_pos - sensor position within subtile (0-15)
'' @returns frame buffer index (0-63) or -1 if invalid parameters

    if subtile > 3 or sensor_pos > 15
        return -1

    return BYTE[@pixel_order][sensor_pos] + BYTE[@subtile_offset][subtile]

PUB debug_frame_mapping() | subtile, sensor, frame_pos
'' Debug helper to print complete sensor-to-frame buffer mapping table
'' @returns nothing - outputs mapping via debug statements

    debug("Sensor to Frame Buffer Mapping:")
    debug("===============================")

    repeat subtile from 0 to 3
        debug("Subtile ", udec(subtile), " (scan order: ", udec(BYTE[@subtile_order][subtile]), "):")

        repeat sensor from 0 to 15
            frame_pos := get_frame_position(subtile, sensor)
            debug("  Sensor ", udec(sensor), " -> Frame[", udec(frame_pos), "] (row ", udec(frame_pos / 8), ", col ", udec(frame_pos // 8), ")")

        debug(" ")

PUB read_single_sensor_bitbang() : value | i, bit_val, raw_value
'' Read single sensor using bit-banged SPI (test mode, main cog)
'' @returns 16-bit ADC value from current sensor position
'' NOTE: Call reset_counter_test() and advance_counter_test() to position sensor first

    ' Configure MISO and SCLK as simple digital I/O (disable smart pin modes)
    PINFLOAT(ABS_PIN_MISO)               ' Float MISO - makes it an input (on P2, float = input)
    PINFLOAT(ABS_PIN_SCLK)               ' Float SCLK - disable smart pin
    PINLOW(ABS_PIN_SCLK)                 ' SCLK low as output

    ' Start conversion (CS low - also captures analog value)
    PINLOW(ABS_PIN_CS)
    WAITUS(2)          ' Critical: 2µs for analog settling

    ' Bit-bang 20 SPI clock cycles to read 16-bit data (4 leading zeros + 16 data)
    raw_value := 0
    repeat i from 0 to 19
        PINLOW(ABS_PIN_SCLK)             ' Clock low
        WAITUS(1)                        ' ~200ns low (minimum waitus is 1µs)

        PINHIGH(ABS_PIN_SCLK)            ' Clock high
        bit_val := PINREAD(ABS_PIN_MISO) ' Read MISO on rising edge
        raw_value := (raw_value << 1) | bit_val  ' Shift in bit
        WAITUS(1)                        ' ~200ns high (minimum waitus is 1µs)

    ' End conversion (CS high)
    PINHIGH(ABS_PIN_CS)
    WAITUS(1)                            ' 1µs quiet time

    ' AD7680 Datasheet (Page 8): 20-bit transfer format
    ' Bits 19-16: 4 leading zeros
    ' Bits 15-0:  16 data bits (MSB first)
    '
    ' Validate the 4 leading zeros (bits 19-16 should all be 0)
    if (raw_value & $F0000) <> 0         ' Check bits 19-16 (4 leading zeros)
        error_count++
        debug("ADC FORMAT ERROR: Leading zeros not zero - raw=0x", uhex_long(raw_value))

    ' Shift right by 4 to remove the 4 leading zeros
    ' This leaves us with the 16-bit data value
    ' NOTE: Magnetic tile appears to use only 12 bits (0-4095 range)
    value := raw_value >> 4

    return value

PUB reset_counter_test()
'' Reset sensor counter to position 0 (test mode, main cog)
'' @returns nothing - prepares for sensor scanning

    PINLOW(ABS_PIN_CLRB)                 ' CLRb low
    WAITUS(1)                            ' 1µs
    PINHIGH(ABS_PIN_CLRB)                ' CLRb high
    WAITUS(1)                            ' 1µs

PUB advance_counter_test()
'' Advance sensor counter to next position (test mode, main cog)
'' @returns nothing - increments sensor mux

    PINHIGH(ABS_PIN_CCLK)                ' CCLK high
    WAITUS(1)                            ' 1µs
    PINLOW(ABS_PIN_CCLK)                 ' CCLK low
    WAITUS(5)                            ' 5µs - allow multiplexer to settle after switching

PUB test_pin_toggle(cycles) | i, pattern, high_mask, low_mask
'' Test all 5 control pins with binary counting pattern (logic analyzer verification)
'' @param cycles - number of counting cycles to perform (counts 0 to cycles-1)
'' @returns nothing - outputs binary patterns for pin identification
'' NOTE: Each pin toggles at a different frequency based on bit position:
''       P8 (CS/bit0) = fastest, P12 (SCLK/bit4) = slowest

    PINCLEAR(CONTROL_PINS_FIELD)                ' All PINS explicitly set to mode 0, float to release any driver

    ' START SIGNATURE: Visible pattern on logic analyzer
    PINHIGH(CONTROL_PINS_FIELD)         ' All 5 pins = HIGH
    WAITMS(200)                         ' Hold HIGH for 200ms

    PINLOW(CONTROL_PINS_FIELD)          ' All 5 pins = LOW
    WAITMS(200)                         ' Hold LOW for 200ms

    ' Binary counting pattern: creates unique signature per pin
    ' Bit 0 (P8/CS)   toggles every cycle
    ' Bit 1 (P9/CCLK) toggles every 2 cycles
    ' Bit 2 (P10/MISO) toggles every 4 cycles
    ' Bit 3 (P11/CLRb) toggles every 8 cycles
    ' Bit 4 (P12/SCLK) toggles every 16 cycles

    repeat i from 0 to cycles-1
        pattern := i & %11111               ' Keep only lowest 5 bits

        ' Write entire 5-bit pattern to all 5 pins at once
        PINWRITE(CONTROL_PINS_FIELD, pattern)

        WAITMS(100)                         ' 100ms per count

    ' END SIGNATURE: Visible pattern on logic analyzer
    PINHIGH(CONTROL_PINS_FIELD)         ' All 5 pins = HIGH
    WAITMS(200)                         ' Hold HIGH for 200ms

    PINLOW(CONTROL_PINS_FIELD)          ' All 5 pins = LOW
    WAITMS(200)                         ' Hold LOW for 200ms

    PINCLEAR(CONTROL_PINS_FIELD)                ' All PINS explicitly set to mode 0, float to release any driver

    ' Leave pins in a safe state (CS high, others low)
    PINHIGH(ABS_PIN_CS)                     ' CS high (inactive) - sets as output
    PINLOW(ABS_PIN_CCLK)                    ' CCLK low - sets as output
    PINLOW(ABS_PIN_CLRB ADDPINS 1)          ' CLRb and SCLK low (2 pins) - sets as output

PUB read_all_sensors_test(buffer_ptr) | i, value
'' Read all 64 sensors in hardware sequence order (test mode, main cog)
'' @param buffer_ptr - pointer to WORD array[64] to receive sensor values
'' @returns nothing - fills buffer with raw sensor values in hardware order
'' NOTE: No remapping applied, values stored in counter sequence 0-63

    if buffer_ptr == 0
        return

    ' Reset counter to start
    reset_counter_test()

    ' Advance to sensor 1 (first active sensor per documentation)
    advance_counter_test()

    ' Read all 64 sensors
    repeat i from 0 to 63
        value := read_single_sensor_bitbang()
        WORD[buffer_ptr][i] := value

        if i < 63                        ' Don't advance after last sensor
            advance_counter_test()

PRI fifo_manager_loop() | framePtr
'' Spin2 FIFO manager loop running in dedicated COG
'' Manages FIFO operations and coordinates with PASM acquisition COG via mailbox

    debug("Sensor FIFO Manager: Loop started", 13, 10)

    repeat
        ' Check if acquisition is active
        if acquisition_mode == MODE_STOPPED
            waitms(10)
            next

        ' Get frame buffer from FIFO
        framePtr := fifo.getNextFrame()
        if framePtr == 0
            ' No buffers available, wait and retry
            waitms(1)
            next

        ' Provide buffer to PASM COG and signal to capture
        mailbox_frame_ptr := framePtr
        mailbox_go_flag := 1

        ' Wait for PASM to complete capture
        repeat until mailbox_go_flag == 0

        ' Commit completed frame to sensor FIFO
        if fifo.commitFrame(fifo.FIFO_SENSOR, framePtr) < 0
            ' FIFO full - release frame back to pool
            fifo.releaseFrame(framePtr)

DAT { background cog code }

                        ORG     0

sensor_cog_entry
                        ' Get parameter pointer (points to frame_count)
                        mov     param_ptr, ptra

                        ' Load addresses from parameter block
                        ' Offset structure: frame_count(0), error_count(4), acq_mode(8), frame_rate(12),
                        '                  last_frame_time(16), min_frame_time(20), max_frame_time(24),
                        '                  baseline[64 WORDs = 128 bytes], baseline_valid(132), base_pin(136)

                        mov     temp, param_ptr
                        add     temp, #8
                        mov     acq_mode_ptr, temp       ' Pointer to acquisition_mode

                        mov     temp, param_ptr
                        add     temp, #12
                        mov     frame_rate_ptr, temp     ' Pointer to frame_rate_target

                        mov     temp, param_ptr
                        add     temp, #28
                        mov     baseline_ptr, temp       ' Pointer to baseline array

                        mov     temp, param_ptr
                        add     temp, #156               ' 28 + 128 bytes baseline array
                        mov     baseline_valid_ptr, temp ' Pointer to baseline_valid flag

                        ' Calculate mailbox addresses
                        mov     temp, param_ptr
                        add     temp, #160               ' Offset to mailbox_frame_ptr
                        mov     mailbox_ptr_addr, temp
                        add     temp, #4                 ' Offset to mailbox_go_flag
                        mov     mailbox_go_addr, temp

                        ' Fixed pin assignments (TILE_PIN_GROUP = 8)
                        mov     cs_pin, #8
                        mov     cclk_pin, #9
                        mov     miso_pin, #10
                        mov     clrb_pin, #11
                        mov     sclk_pin, #12

                        ' Calculate frame period for 375 fps timing
                        mov     frame_period, ##200_000_000  ' System clock frequency
                        mov     temp, #375
                        qdiv    frame_period, temp
                        getqx   frame_period             ' frame_period = clkfreq / 375

acquisition_loop
                        ' Wait for Spin2 FIFO manager to provide buffer (mailbox_go_flag == 1)
                        rdlong  temp, mailbox_go_addr
                        tjz     temp, #acquisition_loop

                        ' Get frame buffer pointer from mailbox
                        rdlong  frame_ptr, mailbox_ptr_addr

                        ' Record frame start time
                        getct   frame_start_time

                        ' Capture sensor frame with remapping and baseline subtraction
                        call    #capture_frame

                        ' Update frame count
                        mov     temp2, param_ptr         ' frame_count at offset 0
                        rdlong  temp, temp2
                        add     temp, #1
                        wrlong  temp, temp2

                        ' Signal completion by clearing go flag (tells Spin2 we're done)
                        wrlong  #0, mailbox_go_addr

                        ' Frame rate control - wait for frame period
                        call    #frame_rate_control

                        jmp     #acquisition_loop

acquisition_exit
                        cogstop #0

capture_frame
                        ' Check if in test pattern mode
                        rdlong  temp, acq_mode_ptr
                        cmp     temp, #4 wz              ' MODE_TEST_PATTERN = 4
                if_z    jmp     #generate_test_pattern

                        ' Normal acquisition mode
                        ' Reset sensor counter to position 0
                        call    #reset_sensor_counter

                        ' Advance to sensor 1 (first active sensor per documentation)
                        call    #advance_sensor_counter

                        ' Check if baseline subtraction is enabled
                        rdlong  baseline_enabled, baseline_valid_ptr

                        ' Read all 64 sensors in correct subtile order: 0, 2, 1, 3
                        mov     subtile_idx, #0
                        mov     linear_index, #0         ' Track linear position 0-63

capture_subtile_loop
                        ' Get current subtile number from subtile_order array
                        mov     temp, ##@subtile_order
                        add     temp, subtile_idx
                        rdbyte  current_subtile, temp

                        ' Get frame buffer offset for this subtile
                        mov     temp, ##@subtile_offset
                        add     temp, current_subtile
                        rdbyte  frame_offset, temp

                        ' Read 16 sensors from current subtile
                        mov     sensor_in_subtile, #0

capture_sensor_loop
                        ' Read sensor value via AD7680
                        call    #read_ad7680

                        ' Apply baseline subtraction if enabled
                        tjz     baseline_enabled, #skip_baseline

                        ' Read baseline value for this sensor
                        mov     temp, baseline_ptr
                        mov     temp2, linear_index
                        shl     temp2, #1                ' WORD offset (* 2)
                        add     temp, temp2
                        rdword  baseline_value, temp

                        ' Subtract baseline (signed operation)
                        subs    sensor_value, baseline_value

skip_baseline
                        ' Map sensor position using pixel_order lookup
                        mov     temp, ##@pixel_order
                        add     temp, sensor_in_subtile
                        rdbyte  pixel_pos, temp

                        ' Calculate final frame buffer position
                        ' frame_position = pixel_pos + frame_offset
                        mov     temp, pixel_pos
                        add     temp, frame_offset

                        ' Store value in frame buffer (word aligned)
                        mov     store_addr, frame_ptr
                        add     store_addr, temp
                        add     store_addr, temp            ' Word offset (*2)
                        wrword  sensor_value, store_addr

                        ' Advance to next sensor in hardware sequence
                        call    #advance_sensor_counter

                        ' Next sensor in subtile
                        add     sensor_in_subtile, #1
                        add     linear_index, #1         ' Track linear position
                        cmp     sensor_in_subtile, #16 wz
                if_nz   jmp     #capture_sensor_loop

                        ' Next subtile
                        add     subtile_idx, #1
                        cmp     subtile_idx, #4 wz
                if_nz   jmp     #capture_subtile_loop

capture_frame_ret       ret

generate_test_pattern
                        ' Generate synthetic test pattern for display verification
                        ' Corner markers with distinct values
                        '
                        ' Frame layout (8x8 grid):
                        '   TL=3000   ...   TR=2500
                        '    ...     1200     ...
                        '   BL=2000   ...   BR=1500

                        ' Fill entire frame with baseline value (1200)
                        mov     linear_index, #0
                        mov     sensor_value, ##1200

fill_baseline_loop
                        ' Calculate store address
                        mov     store_addr, frame_ptr
                        mov     temp, linear_index
                        shl     temp, #1                 ' WORD offset (* 2)
                        add     store_addr, temp
                        wrword  sensor_value, store_addr

                        ' Next position
                        add     linear_index, #1
                        cmp     linear_index, #64 wz
                if_nz   jmp     #fill_baseline_loop

                        ' Set corner markers (in logical 8x8 grid positions)
                        ' TL corner: row=0, col=0 -> index=0
                        mov     store_addr, frame_ptr
                        mov     sensor_value, ##3000
                        wrword  sensor_value, store_addr

                        ' TR corner: row=0, col=7 -> index=7
                        mov     store_addr, frame_ptr
                        add     store_addr, #14          ' 7 * 2 bytes
                        mov     sensor_value, ##2500
                        wrword  sensor_value, store_addr

                        ' BL corner: row=7, col=0 -> index=56
                        mov     store_addr, frame_ptr
                        add     store_addr, #112         ' 56 * 2 bytes
                        mov     sensor_value, ##2000
                        wrword  sensor_value, store_addr

                        ' BR corner: row=7, col=7 -> index=63
                        mov     store_addr, frame_ptr
                        add     store_addr, #126         ' 63 * 2 bytes
                        mov     sensor_value, ##1500
                        wrword  sensor_value, store_addr

                        ' Center marker: row=3, col=3 -> index=27
                        mov     store_addr, frame_ptr
                        add     store_addr, #54          ' 27 * 2 bytes
                        mov     sensor_value, ##2200
                        wrword  sensor_value, store_addr

                        ' Center marker: row=3, col=4 -> index=28
                        mov     store_addr, frame_ptr
                        add     store_addr, #56          ' 28 * 2 bytes
                        mov     sensor_value, ##2200
                        wrword  sensor_value, store_addr

                        ' Center marker: row=4, col=3 -> index=35
                        mov     store_addr, frame_ptr
                        add     store_addr, #70          ' 35 * 2 bytes
                        mov     sensor_value, ##2200
                        wrword  sensor_value, store_addr

                        ' Center marker: row=4, col=4 -> index=36
                        mov     store_addr, frame_ptr
                        add     store_addr, #72          ' 36 * 2 bytes
                        mov     sensor_value, ##2200
                        wrword  sensor_value, store_addr

generate_test_pattern_ret ret

reset_sensor_counter
                        ' Pulse CLRb low to reset counter
                        drvl    clrb_pin
                        waitx   #COUNTER_SETUP_DELAY
                        drvh    clrb_pin
                        waitx   #COUNTER_SETUP_DELAY
reset_sensor_counter_ret ret

advance_sensor_counter
                        ' Pulse CCLK to advance to next sensor
                        drvh    cclk_pin
                        waitx   #COUNTER_SETUP_DELAY
                        drvl    cclk_pin
                        waitx   #COUNTER_SETUP_DELAY
advance_sensor_counter_ret ret

read_ad7680
                        ' Smart pin SPI read
                        ' Start conversion (CS low)
                        drvl    cs_pin
                        waitx   #SENSOR_SETTLE_DELAY

                        ' Start smart pin SPI transfer
                        dirl    miso_pin                ' Reset smart pin
                        dirh    miso_pin                ' Enable smart pin
                        wypin   #0, sclk_pin            ' Start clock generation

                        ' Wait for 24 bits to be received
                        waitx   #48                     ' Wait for 24 clock cycles at configured rate

                        ' Read received data (24 bits: 4 leading zeros + 16 data bits + 4 trailing)
                        rdpin   sensor_value, miso_pin
                        shr     sensor_value, #4       ' Shift right to remove 4 trailing zeros
                        and     sensor_value, ##$FFFF   ' Mask to get 16-bit value

                        ' End conversion (CS high)
                        drvh    cs_pin

read_ad7680_ret         ret

frame_rate_control
                        ' Wait until frame period has elapsed
                        ' frame_period was calculated at startup
                        addct1  frame_start_time, frame_period
                        waitct1                          ' Wait for next frame time
frame_rate_control_ret  ret

' Variables
param_ptr               LONG    0
acq_mode_ptr            LONG    0
frame_rate_ptr          LONG    0
baseline_ptr            LONG    0
baseline_valid_ptr      LONG    0
mailbox_ptr_addr        LONG    0
mailbox_go_addr         LONG    0
cs_pin                  LONG    0
cclk_pin                LONG    0
miso_pin                LONG    0
clrb_pin                LONG    0
sclk_pin                LONG    0
frame_ptr               LONG    0
frame_period            LONG    0
frame_start_time        LONG    0
subtile_idx             LONG    0
current_subtile         LONG    0
frame_offset            LONG    0
sensor_in_subtile       LONG    0
linear_index            LONG    0
pixel_pos               LONG    0
store_addr              LONG    0
sensor_value            LONG    0
baseline_value          LONG    0
baseline_enabled        LONG    0
temp                    LONG    0
temp2                   LONG    0

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
