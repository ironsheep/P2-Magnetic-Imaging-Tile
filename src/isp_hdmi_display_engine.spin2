'' isp_hdmi_display_engine.spin2 - HDMI Display Engine
'' Consumes frames from HDMI FIFO and displays via psram_graphics
''
'' This COG:
''   - Dequeues frames from HDMI FIFO
''   - Converts sensor data to visual representation
''   - Uses psram_graphics API for display

CON
  ' Test mode configuration
  TEST_MODE   = false     ' true = show test pattern, false = process FIFO

  ' Display configuration
  GRID_X      = 200       ' Grid top-left X position
  GRID_Y      = 100       ' Grid top-left Y position
  CELL_SIZE   = 30        ' Size of each sensor cell in pixels
  CELL_GAP    = 3         ' Gap between cells in pixels

  ' Statistics display area (right side of grid)
  STATS_X       = 480     ' Left edge of stats text
  STATS_VALUE_X = 530     ' Left edge of numeric values (after "Min: " etc.)
  STATS_MIN_Y   = 50      ' Y position for Min line
  STATS_MAX_Y   = 65      ' Y position for Max line
  STATS_AVG_Y   = 80      ' Y position for Avg line
  STATS_FRAME_Y = 110     ' Y position for Frame counter
  STATS_CLEAR_W = 80      ' Width to clear for value update

  ' Color mapping ranges - FULL ADC range with observed baseline
  ' See DOCs/MagSensor-Color-Mapping-Specification.md for details
  ' Uses full 16-bit ADC range to accommodate stronger magnets in future
  SENSOR_MIN = 0          ' ADC minimum (theoretical full negative saturation)
  SENSOR_MID = 20500      ' Zero field baseline (observed neutral point)
  SENSOR_MAX = 65535      ' ADC maximum (theoretical full positive saturation)
  NEGATIVE_RANGE = 20500  ' SENSOR_MID - SENSOR_MIN (0 to 20500)
  POSITIVE_RANGE = 45035  ' SENSOR_MAX - SENSOR_MID (20500 to 65535)
  GRAY_BASE = 32          ' Neutral gray intensity (dark gray background)

  ' Stuck pixel indicator color - bright magenta (RRGGBBAA format)
  ' Distinct from red/green field colors, clearly indicates non-operational sensor
  STUCK_PIXEL_COLOR = $FF_00_FF_FF  ' Magenta: R=255, G=0, B=255, A=255

  ' FIFO IDs (must match isp_frame_fifo_manager)
  FIFO_HDMI   = 1

OBJ
  fifo : "isp_frame_fifo_manager"
  gfx  : "isp_psram_graphics"      ' HDMI graphics system
  stack_check : "isp_stack_check"  ' Stack overflow detection utility
  sensor : "isp_tile_sensor"       ' Sensor interface (for stuck pixel detection)

CON { stack configuration }
  HDMI_STACK_SIZE_LONGS = 128      ' Stack size for HDMI display COG (increased from 64 - deep call chains)

VAR
  long  cog_id
  long  frame_count
  long  display_mode
  long  current_frame_ptr
  long  base_pin
  long  grid_drawn              ' Flag: 0=not drawn, 1=drawn
  word  frame_buffer[64]

  ' Dynamic statistics (updated per frame)
  word  stat_min                ' Minimum sensor value in frame
  word  stat_max                ' Maximum sensor value in frame
  long  stat_avg                ' Average sensor value in frame
  byte  text_buf[16]            ' Buffer for number-to-string conversion

DAT { HDMI display COG stack with overflow detection }
  ' Stack for HDMI COG - placed in DAT with sentinel mark for overflow detection
  display_cog_stack   LONG    0[HDMI_STACK_SIZE_LONGS]
  display_stack_mark  LONG    stack_check.DO_NOT_WRITE_MARK   ' Sentinel - overflow if overwritten

PUB null()
  '' Not a top-level object

PUB start(hdmi_base_pin) : ok
  '' Start the HDMI display engine
  '' @param hdmi_base_pin - base pin for HDMI output
  '' @returns cog_id if successful, -1 if failed

  debug("HDMI Engine: Starting...", 13, 10)

  ' Initialize COG ID FIRST (critical - must be set before calling stop()!)
  cog_id := -1

  ' Save pin configuration
  base_pin := hdmi_base_pin

  ' Initialize variables (no palette needed - using direct RGB calculation)
  debug("HDMI Engine: Setting variables...", 13, 10)
  frame_count := 0
  display_mode := 0
  current_frame_ptr := 0
  grid_drawn := 0
  debug("HDMI Engine: Variables set", 13, 10)

  ' Initialize HDMI graphics hardware (one-time, from main COG)
  debug("HDMI Engine: Initializing PSRAM graphics on pin ", udec(hdmi_base_pin), "...", 13, 10)
  gfx.init(hdmi_base_pin)
  debug("HDMI Engine: Graphics hardware initialized", 13, 10)

  ' Stop any existing display COG before starting new one
  stop()

  ' Prepare stack for overflow detection
  stack_check.prepStackForCheck(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

  debug("HDMI Engine: Starting display COG...", 13, 10)
  ' Start display COG
  cog_id := cogspin(NEWCOG, display_loop(), @display_cog_stack)

  if cog_id < 0
    debug("HDMI Engine: ERROR - Failed to start COG!", 13, 10)
  else
    debug("HDMI Engine: COG ", udec(cog_id), " started successfully", 13, 10)

  return cog_id

PUB stop()
  '' Stop the HDMI display engine

  ' Validate COG ID is in valid range (0-7) before stopping
  if cog_id >= 0 and cog_id <= 7
    cogstop(cog_id)
  cog_id := -1

PUB set_display_mode(mode)
  '' Set display visualization mode
  '' @param mode - display mode (0=normal, 1=enhanced contrast, etc.)

  display_mode := mode

PUB get_frame_count() : count
  '' Get number of frames displayed

  return frame_count

PUB get_current_frame() : ptr
  '' Get pointer to current frame buffer (64 WORDs)
  '' @returns pointer to frame_buffer array, or 0 if no frame available

  return current_frame_ptr

' PUB show_test_pattern() | row, col, value
'   '' Display a test pattern directly (bypasses FIFO)
'   '' Removed - graphics drawing now handled in main()

PRI display_loop() | framePtr, row, col, sensorIdx, sensorVal, cellColor
  '' Main display loop running in dedicated COG

  debug("HDMI Engine Loop: COG started, TEST_MODE=", udec(TEST_MODE), 13, 10)

  ' CRITICAL: Show stack address to diagnose memory corruption
  debug("HDMI STACK: ", uhex_long(@display_cog_stack), " to ", uhex_long(@display_cog_stack + (HDMI_STACK_SIZE_LONGS * 4) - 1), 13, 10)

  ' Initialize graphics for this COG (Cog4) - sets up PSRAM mailbox
  debug("HDMI Engine Loop: Initializing graphics for this COG...", 13, 10)
  stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)
  gfx.start()
  debug("HDMI Engine Loop: Graphics initialized for COG ", udec(cogid()), 13, 10)
  stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

  if TEST_MODE
    ' Test pattern mode - just idle for now
    ' (Graphics drawing moved to main)
    debug("HDMI Engine Loop: TEST_MODE active, idling...", 13, 10)
    repeat
      ' Check for stack overflow (halts with debug message if detected)
      stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)
      frame_count++
      waitms(1000)  ' Just keep COG alive
  else
    ' Normal operation - process FIFO frames and render to display
    debug("HDMI Engine Loop: FIFO processing mode active", 13, 10)

    ' Register this COG as HDMI FIFO consumer for event-driven wake-ups
    fifo.registerConsumer(FIFO_HDMI, cogid())
    debug("HDMI Engine Loop: Registered COG ", udec(cogid()), " for event-driven dequeue", 13, 10)

    ' Clear screen and draw grid on startup
    debug("HDMI Engine Loop: Clearing screen...", 13, 10)
    gfx.cls($00_00_00)  ' Black background
    stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

    debug("HDMI Engine Loop: Drawing sensor grid...", 13, 10)
    gfx.DrawSensorGrid(GRID_X, GRID_Y, CELL_SIZE, CELL_GAP)
    stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)
    grid_drawn := 1

    ' Add text labels around the display
    debug("HDMI Engine Loop: Drawing text labels...", 13, 10)
    DrawStaticLabels()
    debug("HDMI Engine Loop: Static labels drawn, grid ready, waiting for frames...", 13, 10)
    stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

    repeat
      ' Check for stack overflow (halts with debug message if detected)
      stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

      ' Event-driven dequeue: sleeps until producer sends COGATN
      ' Zero jitter, zero power while waiting
      framePtr := fifo.dequeueEventDriven(FIFO_HDMI)

      if framePtr <> 0
        ' Render all 64 sensor cells to display
        repeat row from 0 to 7
          repeat col from 0 to 7
            ' Get sensor value from frame
            sensorIdx := row * 8 + col
            sensorVal := WORD[framePtr][sensorIdx]

            ' Check if this sensor is stuck (detected during calibration)
            ' Stuck sensors show as bright magenta to indicate non-operational
            if sensor.is_stuck(sensorIdx)
              cellColor := STUCK_PIXEL_COLOR
            else
              ' Convert sensor value to color
              cellColor := field_to_color(sensorVal)

            ' Render cell to display
            gfx.FillSensorCell(row, col, GRID_X, GRID_Y, CELL_SIZE, CELL_GAP, cellColor)

        ' Increment frame counter
        frame_count++

        ' Calculate and display frame statistics
        CalculateFrameStats(framePtr)
        DrawDynamicStats()

        ' Release frame back to pool
        fifo.releaseFrame(framePtr)
      ' else: spurious wake (race condition) - just loop back

PRI DrawStaticLabels() | row, col, labelX, labelY
  '' Draw static text labels around the sensor grid display
  '' Includes title, row/column labels, and static label prefixes
  '' Dynamic values (min/max/avg/frame) are drawn by DrawDynamicStats()

  ' Title at top center
  gfx.DrawTextCentered(320, 10, @"Magnetic Imaging Tile Display", $FFFFFFFF)  ' White

  ' Row labels (0-7) down left side
  labelX := GRID_X - 20
  repeat row from 0 to 7
    labelY := GRID_Y + row * (CELL_SIZE + CELL_GAP) + 12  ' Centered in cell
    gfx.DrawChar(labelX, labelY, "0" + row, $FFFF00FF)  ' Yellow

  ' Column labels (0-7) across top
  labelY := GRID_Y - 15
  repeat col from 0 to 7
    labelX := GRID_X + col * (CELL_SIZE + CELL_GAP) + 12  ' Centered in cell
    gfx.DrawChar(labelX, labelY, "0" + col, $FFFF00FF)  ' Yellow

  ' Statistics area labels (values drawn dynamically)
  gfx.DrawText(STATS_X, STATS_MIN_Y, @"Min:", $00FF00FF)    ' Green
  gfx.DrawText(STATS_X, STATS_MAX_Y, @"Max:", $FF0000FF)    ' Red
  gfx.DrawText(STATS_X, STATS_AVG_Y, @"Avg:", $00FFFFFF)    ' Cyan
  gfx.DrawText(STATS_X, STATS_FRAME_Y, @"Frame:", $FFFFFFFF) ' White

  ' Status line (bottom left) - static for now
  gfx.DrawText(10, 460, @"Mode: LIVE", $FFFF00FF)  ' Yellow

PRI CalculateFrameStats(framePtr) | i, val, sum
  '' Calculate min, max, and average from frame data
  '' @param framePtr - pointer to 64-word frame buffer
  '' Results stored in stat_min, stat_max, stat_avg

  stat_min := 65535
  stat_max := 0
  sum := 0

  repeat i from 0 to 63
    val := WORD[framePtr][i]

    ' Skip stuck pixels in statistics
    if not sensor.is_stuck(i)
      if val < stat_min
        stat_min := val
      if val > stat_max
        stat_max := val
      sum += val

  ' Calculate average (avoid divide by zero)
  stat_avg := sum / 64

PRI DrawDynamicStats()
  '' Update dynamic statistics display
  '' Call after CalculateFrameStats() to show current values

  ' Clear previous values by drawing black rectangles
  gfx.FillRect(STATS_VALUE_X, STATS_MIN_Y, STATS_VALUE_X + STATS_CLEAR_W, STATS_MIN_Y + 12, $000000FF)
  gfx.FillRect(STATS_VALUE_X, STATS_MAX_Y, STATS_VALUE_X + STATS_CLEAR_W, STATS_MAX_Y + 12, $000000FF)
  gfx.FillRect(STATS_VALUE_X, STATS_AVG_Y, STATS_VALUE_X + STATS_CLEAR_W, STATS_AVG_Y + 12, $000000FF)
  gfx.FillRect(STATS_VALUE_X, STATS_FRAME_Y, STATS_VALUE_X + STATS_CLEAR_W, STATS_FRAME_Y + 12, $000000FF)

  ' Draw min value
  FormatNumber(stat_min)
  gfx.DrawText(STATS_VALUE_X, STATS_MIN_Y, @text_buf, $00FF00FF)  ' Green

  ' Draw max value
  FormatNumber(stat_max)
  gfx.DrawText(STATS_VALUE_X, STATS_MAX_Y, @text_buf, $FF0000FF)  ' Red

  ' Draw avg value
  FormatNumber(stat_avg)
  gfx.DrawText(STATS_VALUE_X, STATS_AVG_Y, @text_buf, $00FFFFFF)  ' Cyan

  ' Draw frame counter
  FormatNumber(frame_count)
  gfx.DrawText(STATS_VALUE_X, STATS_FRAME_Y, @text_buf, $FFFFFFFF)  ' White

PRI FormatNumber(value) | i, digit, started
  '' Convert integer value to zero-terminated string in text_buf
  '' @param value - integer to convert (0-99999)

  ' Handle zero specially
  if value == 0
    text_buf[0] := "0"
    text_buf[1] := 0
    return

  ' Build digits from right to left, then reverse
  i := 0
  repeat while value > 0 and i < 10
    digit := value // 10
    text_buf[i++] := "0" + digit
    value /= 10

  ' Null terminate
  text_buf[i] := 0

  ' Reverse the string in place
  ReverseString(@text_buf, i)

PRI ReverseString(pStr, len) | i, j, temp
  '' Reverse a string in place
  '' @param pStr - pointer to string
  '' @param len - length of string (not including null)

  i := 0
  j := len - 1
  repeat while i < j
    temp := BYTE[pStr][i]
    BYTE[pStr][i] := BYTE[pStr][j]
    BYTE[pStr][j] := temp
    i++
    j--

PRI field_to_color(fieldVal) : color | r, g, b, intensity, linear
  '' Convert magnetic field value to display color using perceptually uniform gradient
  '' @param fieldVal - 16-bit sensor reading
  '' @returns color in RRGGBBAA format (24-bit color, 256 levels per channel)
  ''
  '' Uses gamma-corrected intensity for smooth perceptual gradient.
  '' See DOCs/Visualization-Theory-of-Operations.md for details.
  ''
  '' FIX (2025-12-26): Removed gray_fade to eliminate banding artifact.
  '' Now uses single intensity with gamma correction for perceptually uniform colors.

  ' Clamp to observed range - values beyond just saturate to full color
  fieldVal := SENSOR_MIN #> fieldVal <# SENSOR_MAX

  if fieldVal < SENSOR_MID
    ' Negative field: Red increases from gray background
    linear := ((SENSOR_MID - fieldVal) * 255) / NEGATIVE_RANGE
    intensity := (linear * linear) / 255  ' Gamma correction ~2.0
    r := (GRAY_BASE + intensity) <# 255   ' Red increases from gray (clamped to prevent overflow)
    g := GRAY_BASE
    b := GRAY_BASE
  else
    ' Positive field: Green increases from gray background
    linear := ((fieldVal - SENSOR_MID) * 255) / POSITIVE_RANGE
    intensity := (linear * linear) / 255  ' Gamma correction ~2.0
    r := GRAY_BASE
    g := (GRAY_BASE + intensity) <# 255   ' Green increases from gray (clamped to prevent overflow)
    b := GRAY_BASE

  ' Pack as RRGGBBAA (alpha = FF for fully opaque)
  color := (r << 24) | (g << 16) | (b << 8) | $FF