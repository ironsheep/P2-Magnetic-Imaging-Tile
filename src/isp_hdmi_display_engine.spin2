'' isp_hdmi_display_engine.spin2 - HDMI Display Engine
'' Consumes frames from HDMI FIFO and displays via psram_graphics
''
'' This COG:
''   - Dequeues frames from HDMI FIFO
''   - Converts sensor data to visual representation
''   - Uses psram_graphics API for display

CON
  ' Test mode configuration
  TEST_MODE   = false     ' true = show test pattern, false = process FIFO

  ' Display configuration
  GRID_X      = 200       ' Grid top-left X position
  GRID_Y      = 100       ' Grid top-left Y position
  CELL_SIZE   = 30        ' Size of each sensor cell in pixels
  CELL_GAP    = 3         ' Gap between cells in pixels

  ' Color mapping ranges
  MIN_FIELD   = 0         ' Minimum field value
  MAX_FIELD   = 4095      ' Maximum field value (12-bit from sensor)
  MID_FIELD   = 2048      ' Neutral field value (12-bit midpoint)

  ' FIFO IDs (must match isp_frame_fifo_manager)
  FIFO_HDMI   = 1

OBJ
  fifo : "isp_frame_fifo_manager"
  gfx  : "isp_psram_graphics"      ' HDMI graphics system

VAR
  long  cog_id
  long  frame_count
  long  display_mode
  long  color_palette[8]
  long  current_frame_ptr
  long  base_pin
  long  grid_drawn              ' Flag: 0=not drawn, 1=drawn
  word  frame_buffer[64]

PUB null()
  '' Not a top-level object

PUB start(hdmi_base_pin) : ok
  '' Start the HDMI display engine
  '' @param hdmi_base_pin - base pin for HDMI output
  '' @returns cog_id if successful, -1 if failed

  debug("HDMI Engine: Starting...", 13, 10)

  ' Initialize COG ID FIRST (critical - must be set before calling stop()!)
  cog_id := -1

  ' Save pin configuration
  base_pin := hdmi_base_pin

  ' Initialize color palette for magnetic field visualization
  debug("HDMI Engine: Initializing palette...", 13, 10)
  init_palette()
  debug("HDMI Engine: Palette initialized", 13, 10)

  ' Initialize variables
  debug("HDMI Engine: Setting variables...", 13, 10)
  frame_count := 0
  display_mode := 0
  current_frame_ptr := 0
  grid_drawn := 0
  debug("HDMI Engine: Variables set", 13, 10)

  ' Start HDMI graphics system (engine owns graphics subsystem)
  debug("HDMI Engine: Starting PSRAM graphics on pin ", udec(hdmi_base_pin), "...", 13, 10)
  gfx.start(hdmi_base_pin)
  debug("HDMI Engine: Graphics system ready", 13, 10)

  ' Stop any existing display COG before starting new one
  stop()

  debug("HDMI Engine: Starting display COG...", 13, 10)
  ' Start display COG
  cog_id := cogspin(NEWCOG, display_loop(), @frame_count)

  if cog_id < 0
    debug("HDMI Engine: ERROR - Failed to start COG!", 13, 10)
  else
    debug("HDMI Engine: COG ", udec(cog_id), " started successfully", 13, 10)

  return cog_id

PUB stop()
  '' Stop the HDMI display engine

  ' Validate COG ID is in valid range (0-7) before stopping
  if cog_id >= 0 and cog_id <= 7
    cogstop(cog_id)
  cog_id := -1

PUB set_display_mode(mode)
  '' Set display visualization mode
  '' @param mode - display mode (0=normal, 1=enhanced contrast, etc.)

  display_mode := mode

PUB get_frame_count() : count
  '' Get number of frames displayed

  return frame_count

PUB get_current_frame() : ptr
  '' Get pointer to current frame buffer (64 WORDs)
  '' @returns pointer to frame_buffer array, or 0 if no frame available

  return current_frame_ptr

' PUB show_test_pattern() | row, col, value
'   '' Display a test pattern directly (bypasses FIFO)
'   '' Removed - graphics drawing now handled in main()

PRI init_palette()
  '' Initialize color palette for field strength visualization
  '' Blue (negative) -> Green (neutral) -> Red (positive)

  color_palette[0] := $000080FF  ' Strong negative - Dark blue
  color_palette[1] := $0000FFFF  ' Negative - Bright blue
  color_palette[2] := $0080FFFF  ' Weak negative - Cyan
  color_palette[3] := $00FF00FF  ' Neutral - Green
  color_palette[4] := $80FF00FF  ' Weak positive - Yellow-green
  color_palette[5] := $FFFF00FF  ' Positive - Yellow
  color_palette[6] := $FF8000FF  ' Strong positive - Orange
  color_palette[7] := $FF0000FF  ' Very strong positive - Red

PRI display_loop() | framePtr, row, col, sensorIdx, sensorVal, cellColor
  '' Main display loop running in dedicated COG

  debug("HDMI Engine Loop: COG started, TEST_MODE=", udec(TEST_MODE), 13, 10)

  if TEST_MODE
    ' Test pattern mode - just idle for now
    ' (Graphics drawing moved to main)
    debug("HDMI Engine Loop: TEST_MODE active, idling...", 13, 10)
    repeat
      frame_count++
      waitms(1000)  ' Just keep COG alive
  else
    ' Normal operation - process FIFO frames and render to display
    debug("HDMI Engine Loop: FIFO processing mode active", 13, 10)

    ' Clear screen and draw grid on startup
    debug("HDMI Engine Loop: Clearing screen...", 13, 10)
    gfx.cls($00_00_00)  ' Black background

    debug("HDMI Engine Loop: Drawing sensor grid...", 13, 10)
    gfx.DrawSensorGrid(GRID_X, GRID_Y, CELL_SIZE, CELL_GAP)
    grid_drawn := 1

    ' Add text labels around the display
    debug("HDMI Engine Loop: Drawing text labels...", 13, 10)
    DrawStaticLabels()
    debug("HDMI Engine Loop: Grid ready, waiting for frames...", 13, 10)

    repeat
      ' Dequeue frame from HDMI FIFO (blocking)
      framePtr := fifo.dequeue(FIFO_HDMI)

      if framePtr <> 0
        ' Log first frame received
        if frame_count == 0
          debug("HDMI Engine: First frame received! (ptr=", uhex_long(framePtr), ")", 13, 10)

        ' Render all 64 sensor cells to display
        repeat row from 0 to 7
          repeat col from 0 to 7
            ' Get sensor value from frame
            sensorIdx := row * 8 + col
            sensorVal := WORD[framePtr][sensorIdx]

            ' Convert sensor value to color
            cellColor := field_to_color(sensorVal)

            ' Render cell to display
            gfx.FillSensorCell(row, col, GRID_X, GRID_Y, CELL_SIZE, CELL_GAP, cellColor)

        ' Increment frame counter
        frame_count++

        ' Debug output every 10 frames (every 30 seconds at 1 frame/3 sec)
        if (frame_count // 10) == 0
          debug("HDMI Engine: Rendered ", udec(frame_count), " frames", 13, 10)
          debug("  Corner values: TL=", udec(WORD[framePtr][0]), " TR=", udec(WORD[framePtr][7]), " BL=", udec(WORD[framePtr][56]), " BR=", udec(WORD[framePtr][63]), 13, 10)

        ' Release frame back to pool
        fifo.releaseFrame(framePtr)
      else
        ' FIFO timeout - shouldn't happen in normal operation
        debug("HDMI Engine: FIFO dequeue timeout!", 13, 10)
        waitms(10)

PRI DrawStaticLabels() | row, col, labelX, labelY
  '' Draw static text labels around the sensor grid display
  '' Includes title, row/column labels, and placeholders for statistics

  ' Title at top center
  gfx.DrawTextCentered(320, 10, @"Magnetic Imaging Tile Display", $FFFFFFFF)  ' White

  ' Row labels (0-7) down left side
  labelX := GRID_X - 20
  repeat row from 0 to 7
    labelY := GRID_Y + row * (CELL_SIZE + CELL_GAP) + 12  ' Centered in cell
    gfx.DrawChar(labelX, labelY, "0" + row, $FFFF00FF)  ' Yellow

  ' Column labels (0-7) across top
  labelY := GRID_Y - 15
  repeat col from 0 to 7
    labelX := GRID_X + col * (CELL_SIZE + CELL_GAP) + 12  ' Centered in cell
    gfx.DrawChar(labelX, labelY, "0" + col, $FFFF00FF)  ' Yellow

  ' Statistics area (top right) - sample placeholders
  gfx.DrawText(480, 50, @"Min: 1200", $00FF00FF)   ' Green
  gfx.DrawText(480, 65, @"Max: 3000", $FF0000FF)   ' Red
  gfx.DrawText(480, 80, @"Avg: 2100", $00FFFFFF)   ' Cyan

  ' Frame counter (top right)
  gfx.DrawText(480, 110, @"Frame: 0/10", $FFFFFFFF)  ' White

  ' Status line (bottom left)
  gfx.DrawText(10, 460, @"Mode: TEST_PATTERN", $FFFF00FF)  ' Yellow
  gfx.DrawText(200, 460, @"FIFOs: S:0 H:1 Free:31", $00FF00FF)  ' Green

PRI field_to_color(fieldVal) : color | index
  '' Convert magnetic field value to display color
  '' @param fieldVal - 16-bit sensor reading
  '' @returns color in RRGGBBAA format

  ' Map field value to palette index (0-7)
  if fieldVal < MID_FIELD / 2
    index := 0  ' Strong negative
  elseif fieldVal < MID_FIELD * 3 / 4
    index := 1  ' Negative
  elseif fieldVal < MID_FIELD * 7 / 8
    index := 2  ' Weak negative
  elseif fieldVal < MID_FIELD * 9 / 8
    index := 3  ' Neutral
  elseif fieldVal < MID_FIELD * 5 / 4
    index := 4  ' Weak positive
  elseif fieldVal < MID_FIELD * 3 / 2
    index := 5  ' Positive
  elseif fieldVal < MID_FIELD * 7 / 4
    index := 6  ' Strong positive
  else
    index := 7  ' Very strong positive

  ' Apply display mode transformations if needed
  case display_mode
    0:  ' Normal mode
      color := color_palette[index]
    1:  ' Enhanced contrast mode
      ' Expand the color range for better visibility
      if index < 3
        index := 0  ' More blue
      elseif index > 4
        index := 7  ' More red
      color := color_palette[index]
    other:
      color := color_palette[index]

  return color