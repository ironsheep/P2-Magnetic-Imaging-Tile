'' isp_hdmi_display_engine.spin2 - HDMI Display Engine
'' Consumes frames from HDMI FIFO and displays via psram_graphics
''
'' This COG:
''   - Dequeues frames from HDMI FIFO
''   - Converts sensor data to visual representation
''   - Uses psram_graphics API for display

CON
  ' Test mode configuration
  TEST_MODE   = false     ' true = show test pattern, false = process FIFO

  ' Display configuration
  GRID_X      = 200       ' Grid top-left X position
  GRID_Y      = 100       ' Grid top-left Y position
  CELL_SIZE   = 30        ' Size of each sensor cell in pixels
  CELL_GAP    = 3         ' Gap between cells in pixels

  ' Color mapping ranges - FULL ADC range with observed baseline
  ' See DOCs/MagSensor-Color-Mapping-Specification.md for details
  ' Uses full 16-bit ADC range to accommodate stronger magnets in future
  SENSOR_MIN = 0          ' ADC minimum (theoretical full negative saturation)
  SENSOR_MID = 20500      ' Zero field baseline (observed neutral point)
  SENSOR_MAX = 65535      ' ADC maximum (theoretical full positive saturation)
  NEGATIVE_RANGE = 20500  ' SENSOR_MID - SENSOR_MIN (0 to 20500)
  POSITIVE_RANGE = 45035  ' SENSOR_MAX - SENSOR_MID (20500 to 65535)
  GRAY_BASE = 32          ' Neutral gray intensity (dark gray background)

  ' FIFO IDs (must match isp_frame_fifo_manager)
  FIFO_HDMI   = 1

OBJ
  fifo : "isp_frame_fifo_manager"
  gfx  : "isp_psram_graphics"      ' HDMI graphics system
  stack_check : "isp_stack_check"  ' Stack overflow detection utility

CON { stack configuration }
  HDMI_STACK_SIZE_LONGS = 128      ' Stack size for HDMI display COG (increased from 64 - deep call chains)

VAR
  long  cog_id
  long  frame_count
  long  display_mode
  long  current_frame_ptr
  long  base_pin
  long  grid_drawn              ' Flag: 0=not drawn, 1=drawn
  word  frame_buffer[64]

DAT { HDMI display COG stack with overflow detection }
  ' Stack for HDMI COG - placed in DAT with sentinel mark for overflow detection
  display_cog_stack   LONG    0[HDMI_STACK_SIZE_LONGS]
  display_stack_mark  LONG    stack_check.DO_NOT_WRITE_MARK   ' Sentinel - overflow if overwritten

PUB null()
  '' Not a top-level object

PUB start(hdmi_base_pin) : ok
  '' Start the HDMI display engine
  '' @param hdmi_base_pin - base pin for HDMI output
  '' @returns cog_id if successful, -1 if failed

  debug("HDMI Engine: Starting...", 13, 10)

  ' Initialize COG ID FIRST (critical - must be set before calling stop()!)
  cog_id := -1

  ' Save pin configuration
  base_pin := hdmi_base_pin

  ' Initialize variables (no palette needed - using direct RGB calculation)
  debug("HDMI Engine: Setting variables...", 13, 10)
  frame_count := 0
  display_mode := 0
  current_frame_ptr := 0
  grid_drawn := 0
  debug("HDMI Engine: Variables set", 13, 10)

  ' Initialize HDMI graphics hardware (one-time, from main COG)
  debug("HDMI Engine: Initializing PSRAM graphics on pin ", udec(hdmi_base_pin), "...", 13, 10)
  gfx.init(hdmi_base_pin)
  debug("HDMI Engine: Graphics hardware initialized", 13, 10)

  ' Stop any existing display COG before starting new one
  stop()

  ' Prepare stack for overflow detection
  stack_check.prepStackForCheck(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

  debug("HDMI Engine: Starting display COG...", 13, 10)
  ' Start display COG
  cog_id := cogspin(NEWCOG, display_loop(), @display_cog_stack)

  if cog_id < 0
    debug("HDMI Engine: ERROR - Failed to start COG!", 13, 10)
  else
    debug("HDMI Engine: COG ", udec(cog_id), " started successfully", 13, 10)

  return cog_id

PUB stop()
  '' Stop the HDMI display engine

  ' Validate COG ID is in valid range (0-7) before stopping
  if cog_id >= 0 and cog_id <= 7
    cogstop(cog_id)
  cog_id := -1

PUB set_display_mode(mode)
  '' Set display visualization mode
  '' @param mode - display mode (0=normal, 1=enhanced contrast, etc.)

  display_mode := mode

PUB get_frame_count() : count
  '' Get number of frames displayed

  return frame_count

PUB get_current_frame() : ptr
  '' Get pointer to current frame buffer (64 WORDs)
  '' @returns pointer to frame_buffer array, or 0 if no frame available

  return current_frame_ptr

' PUB show_test_pattern() | row, col, value
'   '' Display a test pattern directly (bypasses FIFO)
'   '' Removed - graphics drawing now handled in main()

PRI display_loop() | framePtr, row, col, sensorIdx, sensorVal, cellColor
  '' Main display loop running in dedicated COG

  debug("HDMI Engine Loop: COG started, TEST_MODE=", udec(TEST_MODE), 13, 10)

  ' CRITICAL: Show stack address to diagnose memory corruption
  debug("HDMI STACK: ", uhex_long(@display_cog_stack), " to ", uhex_long(@display_cog_stack + (HDMI_STACK_SIZE_LONGS * 4) - 1), 13, 10)

  ' Initialize graphics for this COG (Cog4) - sets up PSRAM mailbox
  debug("HDMI Engine Loop: Initializing graphics for this COG...", 13, 10)
  stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)
  gfx.start()
  debug("HDMI Engine Loop: Graphics initialized for COG ", udec(cogid()), 13, 10)
  stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

  if TEST_MODE
    ' Test pattern mode - just idle for now
    ' (Graphics drawing moved to main)
    debug("HDMI Engine Loop: TEST_MODE active, idling...", 13, 10)
    repeat
      ' Check for stack overflow (halts with debug message if detected)
      stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)
      frame_count++
      waitms(1000)  ' Just keep COG alive
  else
    ' Normal operation - process FIFO frames and render to display
    debug("HDMI Engine Loop: FIFO processing mode active", 13, 10)

    ' Clear screen and draw grid on startup
    debug("HDMI Engine Loop: Clearing screen...", 13, 10)
    gfx.cls($00_00_00)  ' Black background
    stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

    debug("HDMI Engine Loop: Drawing sensor grid...", 13, 10)
    gfx.DrawSensorGrid(GRID_X, GRID_Y, CELL_SIZE, CELL_GAP)
    stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)
    grid_drawn := 1

    ' Add text labels around the display
    debug("HDMI Engine Loop: Drawing text labels...", 13, 10)
    ' TEMPORARILY DISABLED - Testing if grid and sensor display work without text
    'DrawStaticLabels()
    debug("HDMI Engine Loop: Text drawing disabled for testing, grid ready, waiting for frames...", 13, 10)
    stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

    repeat
      ' Check for stack overflow (halts with debug message if detected)
      stack_check.checkStack(@display_cog_stack, HDMI_STACK_SIZE_LONGS)

      ' Dequeue frame from HDMI FIFO (blocking)
      framePtr := fifo.dequeue(FIFO_HDMI)
      debug("HDMI: DEQUEUE ptr=", uhex_long(framePtr))

      if framePtr <> 0
        ' Render all 64 sensor cells to display
        repeat row from 0 to 7
          repeat col from 0 to 7
            ' Get sensor value from frame
            sensorIdx := row * 8 + col
            sensorVal := WORD[framePtr][sensorIdx]

            ' Convert sensor value to color
            cellColor := field_to_color(sensorVal)

            ' Render cell to display
            gfx.FillSensorCell(row, col, GRID_X, GRID_Y, CELL_SIZE, CELL_GAP, cellColor)

        ' Increment frame counter
        frame_count++

        ' Release frame back to pool
        debug("HDMI: RELEASE ptr=", uhex_long(framePtr))
        fifo.releaseFrame(framePtr)
      else
        ' FIFO timeout - shouldn't happen in normal operation
        debug("HDMI: DEQUEUE timeout")
        waitms(10)

PRI DrawStaticLabels() | row, col, labelX, labelY
  '' Draw static text labels around the sensor grid display
  '' Includes title, row/column labels, and placeholders for statistics

  ' Title at top center
  gfx.DrawTextCentered(320, 10, @"Magnetic Imaging Tile Display", $FFFFFFFF)  ' White

  ' Row labels (0-7) down left side
  labelX := GRID_X - 20
  repeat row from 0 to 7
    labelY := GRID_Y + row * (CELL_SIZE + CELL_GAP) + 12  ' Centered in cell
    gfx.DrawChar(labelX, labelY, "0" + row, $FFFF00FF)  ' Yellow

  ' Column labels (0-7) across top
  labelY := GRID_Y - 15
  repeat col from 0 to 7
    labelX := GRID_X + col * (CELL_SIZE + CELL_GAP) + 12  ' Centered in cell
    gfx.DrawChar(labelX, labelY, "0" + col, $FFFF00FF)  ' Yellow

  ' Statistics area (top right) - sample placeholders
  gfx.DrawText(480, 50, @"Min: 1200", $00FF00FF)   ' Green
  gfx.DrawText(480, 65, @"Max: 3000", $FF0000FF)   ' Red
  gfx.DrawText(480, 80, @"Avg: 2100", $00FFFFFF)   ' Cyan

  ' Frame counter (top right)
  gfx.DrawText(480, 110, @"Frame: 0/10", $FFFFFFFF)  ' White

  ' Status line (bottom left)
  gfx.DrawText(10, 460, @"Mode: TEST_PATTERN", $FFFF00FF)  ' Yellow
  gfx.DrawText(200, 460, @"FIFOs: S:0 H:1 Free:31", $00FF00FF)  ' Green

PRI field_to_color(fieldVal) : color | r, g, b, intensity, gray_fade
  '' Convert magnetic field value to display color using direct RGB calculation
  '' @param fieldVal - 16-bit sensor reading
  '' @returns color in RRGGBBAA format (24-bit color, 256 levels per channel)
  ''
  '' Formula from DOCs/MagSensor-Color-Mapping-Specification.md:
  ''   Negative field (< SENSOR_MID): Red intensity proportional to deviation
  ''   Positive field (> SENSOR_MID): Green intensity proportional to deviation
  ''   Neutral (= SENSOR_MID): Dark gray
  ''
  '' Values beyond observed range saturate to full color intensity.

  ' Clamp to observed range - values beyond just saturate to full color
  fieldVal := SENSOR_MIN #> fieldVal <# SENSOR_MAX

  if fieldVal < SENSOR_MID
    ' Negative field: Red with fading gray
    ' intensity = 255 * (SENSOR_MID - fieldVal) / NEGATIVE_RANGE
    ' gray_fade = GRAY_BASE * (fieldVal - SENSOR_MIN) / NEGATIVE_RANGE
    intensity := ((SENSOR_MID - fieldVal) * 255) / NEGATIVE_RANGE
    gray_fade := ((fieldVal - SENSOR_MIN) * GRAY_BASE) / NEGATIVE_RANGE
    r := intensity
    g := gray_fade
    b := gray_fade
  else
    ' Positive field: Green with fading gray
    ' intensity = 255 * (fieldVal - SENSOR_MID) / POSITIVE_RANGE
    ' gray_fade = GRAY_BASE * (SENSOR_MAX - fieldVal) / POSITIVE_RANGE
    intensity := ((fieldVal - SENSOR_MID) * 255) / POSITIVE_RANGE
    gray_fade := ((SENSOR_MAX - fieldVal) * GRAY_BASE) / POSITIVE_RANGE
    r := gray_fade
    g := intensity
    b := gray_fade

  ' Pack as RRGGBBAA (alpha = FF for fully opaque)
  color := (r << 24) | (g << 16) | (b << 8) | $FF