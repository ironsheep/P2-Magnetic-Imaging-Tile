'' =================================================================================================
''
''   File....... frame_queue.spin2
''   Purpose.... Frame buffer queue management for magnetic imaging tile
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Jan 2025
''
'' =================================================================================================

CON { frame queue constants }

    MAX_FRAMES = 32                     ' Maximum frames in queue (configurable)
    FRAME_SIZE_WORDS = 64               ' 64 sensors per frame
    FRAME_SIZE_BYTES = FRAME_SIZE_WORDS * 2  ' 2 bytes per sensor reading

DAT { frame buffer pool }

    ' Pre-allocated frame buffer pool
    frame_buffers   WORD    0[MAX_FRAMES * FRAME_SIZE_WORDS]

    ' Queue management variables
    queue_head      LONG    0           ' Index of next frame to write
    queue_tail      LONG    0           ' Index of next frame to read
    queue_count     LONG    0           ' Number of frames currently queued
    queue_lock      LONG    0           ' Mutex for thread-safe access

VAR { frame queue variables }

    LONG    initialized
    LONG    dropped_frames              ' Counter for dropped frames (queue full)
    LONG    total_frames                ' Total frames processed

PUB start() : success
'' Start the frame queue system
'' Returns: TRUE if successful, FALSE if already initialized

    if initialized
        return FALSE

    ' Initialize queue pointers
    queue_head := 0
    queue_tail := 0
    queue_count := 0
    dropped_frames := 0
    total_frames := 0

    ' Initialize mutex
    queue_lock := 0

    initialized := TRUE
    return TRUE

PUB stop()
'' Stop the frame queue system

    initialized := FALSE

PUB allocate_frame_buffer() : buffer_ptr | head_idx
'' Stage 1: Get exclusive access to next available frame buffer
'' Returns: Direct pointer to buffer for zero-copy writing, or 0 if queue is full
'' NOTE: Caller must call release_to_queue() after filling buffer

    if not initialized
        return 0

    ' Thread-safe check for queue full
    repeat while locknew() == queue_lock

    if queue_count >= MAX_FRAMES
        lockret(queue_lock)
        dropped_frames++
        return 0                        ' Queue full

    ' Calculate buffer address for current head position
    head_idx := queue_head
    buffer_ptr := @frame_buffers + (head_idx * FRAME_SIZE_BYTES)

    lockret(queue_lock)
    return buffer_ptr

PUB release_to_queue()
'' Stage 2: Release filled buffer to queue for consumption
'' Must be called after allocate_frame_buffer() and filling the buffer
'' This completes the zero-copy two-stage buffer allocation

    if not initialized
        return

    ' Thread-safe queue update
    repeat while locknew() == queue_lock

    ' Advance head pointer
    queue_head := (queue_head + 1) // MAX_FRAMES
    queue_count++
    total_frames++

    lockret(queue_lock)

PUB dequeue_frame() : frame_ptr | tail_idx
'' Get pointer to next available frame for reading
'' Returns: Pointer to frame buffer, or 0 if queue is empty
'' NOTE: Caller must call release_frame() after processing

    if not initialized
        return 0

    ' Thread-safe check for queue empty
    repeat while locknew() == queue_lock

    if queue_count == 0
        lockret(queue_lock)
        return 0                        ' Queue empty

    ' Calculate buffer address for current tail position
    tail_idx := queue_tail
    frame_ptr := @frame_buffers + (tail_idx * FRAME_SIZE_BYTES)

    lockret(queue_lock)
    return frame_ptr

PUB release_frame()
'' Release the frame buffer obtained from dequeue_frame()
'' Must be called after dequeue_frame() and processing the frame

    if not initialized
        return

    ' Thread-safe queue update
    repeat while locknew() == queue_lock

    ' Advance tail pointer
    queue_tail := (queue_tail + 1) // MAX_FRAMES
    queue_count--

    lockret(queue_lock)

PUB get_queue_depth() : depth
'' Get current number of frames in queue
'' Returns: Number of queued frames

    if not initialized
        return 0

    repeat while locknew() == queue_lock
    depth := queue_count
    lockret(queue_lock)

PUB get_queue_stats(stats_ptr)
'' Get queue statistics
'' Parameters:
''   stats_ptr - pointer to LONG array[4] to receive stats
''               [0] = current queue depth
''               [1] = dropped frames count
''               [2] = total frames processed
''               [3] = queue utilization percentage

    if not initialized or stats_ptr == 0
        return

    repeat while locknew() == queue_lock

    LONG[stats_ptr][0] := queue_count
    LONG[stats_ptr][1] := dropped_frames
    LONG[stats_ptr][2] := total_frames

    ' Calculate utilization percentage
    if total_frames > 0
        LONG[stats_ptr][3] := (queue_count * 100) / MAX_FRAMES
    else
        LONG[stats_ptr][3] := 0

    lockret(queue_lock)

PUB is_queue_full() : full
'' Check if queue is full
'' Returns: TRUE if full, FALSE otherwise

    if not initialized
        return FALSE

    repeat while locknew() == queue_lock
    full := (queue_count >= MAX_FRAMES)
    lockret(queue_lock)

PUB is_queue_empty() : empty
'' Check if queue is empty
'' Returns: TRUE if empty, FALSE otherwise

    if not initialized
        return TRUE

    repeat while locknew() == queue_lock
    empty := (queue_count == 0)
    lockret(queue_lock)

PUB clear_queue()
'' Clear all frames from queue (emergency reset)

    if not initialized
        return

    repeat while locknew() == queue_lock

    queue_head := 0
    queue_tail := 0
    queue_count := 0

    lockret(queue_lock)

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}