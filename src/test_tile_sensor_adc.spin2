'' =================================================================================================
''   File....... test_tile_sensor_adc.spin2
''   Purpose.... Test ADC interface for Magnetic Imaging Tile - All 64 sensor verification
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Jan 2025
''
'' =================================================================================================
''
''  PHASE 2 TEST: Verify all 64 sensors can be read
''
''  SUCCESS CRITERIA:
''  1. All 64 sensors produce valid values (not stuck at 0 or 65535)
''  2. Sensors show variation (multiplexer is working)
''  3. Counter advances correctly through all positions
''  4. No dead or stuck sensors
''
''  HARDWARE SETUP:
''  - Connect magnetic tile to Pin Group 8 (P8-P15)
''  - No magnetic field near sensors initially
''  - Have small magnet ready for testing
''
''  TEST PROCEDURE:
''  1. Read all 64 sensors sequentially
''  2. Report value for each sensor
''  3. Calculate statistics (min/max/avg/unique values)
''  4. Verify multiplexer is switching correctly
''
'' =================================================================================================

CON
    _clkfreq = 250_000_000                  ' 250 MHz system clock
    DEBUG_BAUD = 2_000_000                  ' 2 Mbps debug output

    ' Pin group for magnetic tile (from README.md)
    TILE_PIN_GROUP = 8                      ' Pin Group 8: P8-P15

    ' Test parameters
    NUM_SENSORS = 64                        ' Total sensors in 8x8 array
    EXPECTED_ZERO_FIELD = 32768             ' Expected mid-scale value (16-bit)
    MIN_UNIQUE_VALUES = 10                  ' Minimum unique values to prove multiplexer working

    ' Performance test parameters
    EXPECTED_FRAME_TIME_US = 2667           ' Target: ~375 fps (2667 us per frame)
    PERFORMANCE_TOLERANCE = 10              ' Allow ±10% deviation from target

OBJ
    tile : "isp_tile_sensor"                ' Magnetic tile sensor driver
    fifo : "isp_frame_fifo_manager"         ' Frame FIFO for pipeline test

VAR
    LONG sensor_values[NUM_SENSORS]         ' All 64 sensor readings
    LONG test_stats[6]                      ' min, max, avg, stddev, range, unique_count

PUB main() | i, value, result

    debug("*** TEST START ***", 13, 10)
    debug("================================================================================", 13, 10)
    debug("Magnetic Tile ADC Test - Phase 2: All 64 Sensors", 13, 10)
    debug("================================================================================", 13, 10)
    debug(" ", 13, 10)

    ' Initialize tile sensor for testing
    ' NOTE: We do NOT call tile.start() because that launches a background COG
    '       which requires the FIFO manager. For testing, we directly configure
    '       the smart pins and use the test methods.
    debug("Tile sensor test - Pin Group: P8-P15", 13, 10)
    debug(" ", 13, 10)

    ' Configure smart pins for test methods
    debug("Configuring smart pins for SPI interface...", 13, 10)
    tile.configure_smart_pins()
    debug("Smart pins configured", 13, 10)
    debug(" ", 13, 10)

    ' Read all 64 sensors
    debug("TEST: Reading All 64 Sensors")
    debug("----------------------------")
    debug("Stepping through counter positions 0-63...")
    debug(" ")

    tile.reset_counter_test()               ' Reset to sensor 0

    repeat i from 0 to NUM_SENSORS-1
        tile.advance_counter_test()         ' Advance to next sensor
        sensor_values[i] := tile.read_single_sensor()

        ' After every 8th sensor, dump all 8 values for logic analyzer validation
        if (i+1) // 8 == 0
            debug("  Sensors ", udec_(i-7), "-", udec_(i), ": ", uhex_word_(sensor_values[i-7]), " ", uhex_word_(sensor_values[i-6]), " ", uhex_word_(sensor_values[i-5]), " ", uhex_word_(sensor_values[i-4]), " ", uhex_word_(sensor_values[i-3]), " ", uhex_word_(sensor_values[i-2]), " ", uhex_word_(sensor_values[i-1]), " ", uhex_word(sensor_values[i]))

    debug(" ")

    ' Calculate statistics
    calculate_stats(@sensor_values, NUM_SENSORS, @test_stats)

    debug("SENSOR ARRAY RESULTS:")
    debug("  Minimum value:   ", udec(test_stats[0]), " (0x", uhex_word(test_stats[0]), ")")
    debug("  Maximum value:   ", udec(test_stats[1]), " (0x", uhex_word(test_stats[1]), ")")
    debug("  Average value:   ", udec(test_stats[2]))
    debug("  Std Deviation:   ", udec(test_stats[3]))
    debug("  Range (max-min): ", udec(test_stats[4]))
    debug("  Unique values:   ", udec(test_stats[5]))
    debug(" ")

    ' Evaluate multiplexer operation
    if test_stats[5] < MIN_UNIQUE_VALUES
        debug("FAIL: Too few unique values (", udec(test_stats[5]), " < ", udec(MIN_UNIQUE_VALUES), ")")
        debug("      Multiplexer may not be switching correctly")
        debug("      All sensors showing nearly same value")
    else
        debug("PASS: Multiplexer working (", udec(test_stats[5]), " unique values)")

    debug(" ")

    ' Check for stuck sensors
    if test_stats[0] == 0
        debug("WARN: At least one sensor reading 0 - possible wiring issue")
    elseif test_stats[1] == 65535
        debug("WARN: At least one sensor reading max - possible stuck ADC")
    else
        debug("PASS: All sensors in valid range")

    debug(" ")

    ' Summary
    debug("SUMMARY:")
    debug("  Total sensors tested: ", udec(NUM_SENSORS))
    debug("  Value range: ", udec(test_stats[0]), " to ", udec(test_stats[1]))
    debug("  Spread: ", udec(test_stats[4]), " counts")
    if test_stats[5] >= MIN_UNIQUE_VALUES
        debug("  PASS: Counter and multiplexer working correctly")
    else
        debug("  FAIL: Insufficient variation - check hardware")

    debug(" ")
    debug("================================================================================")
    debug("PERFORMANCE TESTS")
    debug("================================================================================")
    debug(" ")

    ' Run performance tests
    run_raw_performance_test()
    debug(" ")
    run_pipeline_performance_test()

    debug(" ")
    debug("================================================================================")
    debug("AUTOMATED TESTS COMPLETE")
    debug("================================================================================")
    debug(" ")
    debug("END_SESSION")  ' Marker for automated test script

PRI run_raw_performance_test() | i, start_ct, end_ct, cycles, frame_time_us, frame_rate, sensor_time_us, deviation, pass_fail
'' TEST 1: Raw hardware performance measurement
'' Measures pure ADC/SPI interface speed without FIFO overhead

    debug("TEST 1: Raw Hardware Performance")
    debug("----------------------------------")
    debug("Measuring 64-sensor scan using smart pin SPI interface...")
    debug(" ")

    ' Reset counter
    tile.reset_counter_test()

    ' Measure complete frame acquisition
    start_ct := GETCT()

    repeat i from 0 to NUM_SENSORS-1
        tile.advance_counter_test()
        sensor_values[i] := tile.read_single_sensor()

    end_ct := GETCT()

    ' Calculate performance metrics @ 250 MHz
    cycles := end_ct - start_ct
    frame_time_us := cycles / 250                ' cycles / (250 MHz / 1 MHz)
    frame_rate := 1_000_000 / frame_time_us      ' fps
    sensor_time_us := frame_time_us / 64         ' us per sensor

    ' Calculate deviation from target (negative = faster than target)
    deviation := ((frame_time_us - EXPECTED_FRAME_TIME_US) * 100) / EXPECTED_FRAME_TIME_US

    ' Pass/fail check: PASS if faster than target OR within tolerance
    ' Faster than target (negative deviation) is always good
    if deviation < 0
        pass_fail := TRUE                       ' Faster than target = PASS
    else
        pass_fail := (deviation <= PERFORMANCE_TOLERANCE)  ' Slower must be within tolerance

    ' Report results
    debug("RESULTS:")
    debug("  Total cycles:      ", udec(cycles))
    debug("  Frame time:        ", udec(frame_time_us), " us")
    debug("  Frame rate:        ", udec(frame_rate), " fps")
    debug("  Time per sensor:   ", udec(sensor_time_us), " us")
    debug("  Target frame time: ", udec(EXPECTED_FRAME_TIME_US), " us (375 fps)")
    debug("  Deviation:         ", sdec(deviation), "%")

    if pass_fail
        if deviation < 0
            debug("  Status:            PASS (faster than target by ", udec(-deviation), "%)")
        else
            debug("  Status:            PASS (within ", udec(PERFORMANCE_TOLERANCE), "% tolerance)")
    else
        debug("  Status:            FAIL (exceeds ", udec(PERFORMANCE_TOLERANCE), "% tolerance)")
        debug("  NOTE: Check SPI timing, settling delays, or hardware")

PRI run_pipeline_performance_test() | i, start_ct, end_ct, cycles, frame_time_us, frame_rate, framePtr, deviation, pass_fail
'' TEST 2: Production pipeline performance with FIFO
'' Measures complete production code path including frame pool and FIFO operations

    debug("TEST 2: Production Pipeline Performance")
    debug("----------------------------------------")
    debug("Measuring frame acquisition with FIFO commits...")
    debug(" ")

    ' Initialize FIFO manager
    if not fifo.start()
        debug("ERROR: Failed to start FIFO manager")
        return

    debug("FIFO manager started")
    debug(" ")

    ' Reset counter
    tile.reset_counter_test()

    ' Measure complete frame acquisition with FIFO
    start_ct := GETCT()

    ' Get frame from pool
    framePtr := fifo.getNextFrame()

    if framePtr
        ' Fill frame with sensor data
        repeat i from 0 to NUM_SENSORS-1
            tile.advance_counter_test()
            WORD[framePtr][i] := tile.read_single_sensor()

        ' Commit to sensor FIFO
        fifo.commitFrame(fifo.FIFO_SENSOR, framePtr)

    end_ct := GETCT()

    ' Calculate performance metrics @ 250 MHz
    cycles := end_ct - start_ct
    frame_time_us := cycles / 250                ' cycles / (250 MHz / 1 MHz)
    frame_rate := 1_000_000 / frame_time_us      ' fps

    ' Calculate deviation from target (negative = faster than target)
    deviation := ((frame_time_us - EXPECTED_FRAME_TIME_US) * 100) / EXPECTED_FRAME_TIME_US

    ' Pass/fail check: PASS if faster than target OR within tolerance
    if deviation < 0
        pass_fail := TRUE                       ' Faster than target = PASS
    else
        pass_fail := (deviation <= PERFORMANCE_TOLERANCE)  ' Slower must be within tolerance

    ' Report results
    debug("RESULTS:")
    debug("  Total cycles:      ", udec(cycles))
    debug("  Frame time:        ", udec(frame_time_us), " us")
    debug("  Frame rate:        ", udec(frame_rate), " fps")
    debug("  Target frame time: ", udec(EXPECTED_FRAME_TIME_US), " us (375 fps)")
    debug("  Deviation:         ", sdec(deviation), "%")
    debug("  FIFO overhead:     ", udec(frame_time_us - (cycles / 250)), " us")

    if pass_fail
        if deviation < 0
            debug("  Status:            PASS (faster than target by ", udec(-deviation), "%)")
        else
            debug("  Status:            PASS (within ", udec(PERFORMANCE_TOLERANCE), "% tolerance)")
        debug("  NOTE: Production pipeline meets/exceeds target performance")
    else
        debug("  Status:            FAIL (exceeds ", udec(PERFORMANCE_TOLERANCE), "% tolerance)")
        debug("  NOTE: FIFO/memory operations causing bottleneck")

    ' Report FIFO status
    debug(" ")
    debug("FIFO STATUS:")
    debug("  Sensor FIFO depth: ", udec(fifo.getQueueDepth(fifo.FIFO_SENSOR)))
    debug("  Free frames:       ", udec(fifo.getFreeFrames()))

PRI calculate_stats(data_ptr, count, stats_ptr) | i, j, sum, min_val, max_val, avg, variance, diff, value, unique_count, is_unique

    if data_ptr == 0 or stats_ptr == 0 or count == 0
        return

    ' Find min, max, and calculate sum
    min_val := LONG[data_ptr][0]
    max_val := LONG[data_ptr][0]
    sum := 0

    repeat i from 0 to count-1
        value := LONG[data_ptr][i]
        sum += value

        if value < min_val
            min_val := value
        if value > max_val
            max_val := value

    ' Calculate average
    avg := sum / count

    ' Calculate variance (for std deviation)
    variance := 0
    repeat i from 0 to count-1
        diff := LONG[data_ptr][i] - avg
        variance += diff * diff

    variance := variance / count

    ' Count unique values (simple but slow O(n²) method - fine for 64 sensors)
    unique_count := 0
    repeat i from 0 to count-1
        is_unique := true
        ' Check if this value appeared earlier
        repeat j from 0 to i-1
            if LONG[data_ptr][i] == LONG[data_ptr][j]
                is_unique := false
                quit
        if is_unique
            unique_count++

    ' Store results
    LONG[stats_ptr][0] := min_val
    LONG[stats_ptr][1] := max_val
    LONG[stats_ptr][2] := avg
    LONG[stats_ptr][3] := sqrt_approx(variance)  ' Std deviation
    LONG[stats_ptr][4] := max_val - min_val      ' Range
    LONG[stats_ptr][5] := unique_count           ' Unique values

PRI sqrt_approx(x) : result | guess, new_guess, i
'' Fast integer square root using Newton's method

    if x <= 1
        return x

    guess := x >> 1                         ' Initial guess: x/2

    ' Newton iterations
    repeat i from 0 to 7                    ' 8 iterations sufficient
        new_guess := (guess + x / guess) >> 1
        if new_guess == guess
            return guess                    ' Converged
        guess := new_guess

    return guess

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
