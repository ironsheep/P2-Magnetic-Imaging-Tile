'' =================================================================================================
''
''   File....... test_system.spin2
''   Purpose.... Test program for magnetic imaging tile sensor system
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Jan 2025
''
'' =================================================================================================

CON { test system constants }

    _CLKFREQ = 200_000_000                  ' 200 MHz system clock

    ' Pin group configuration
    SENSOR_PIN_GROUP = 48                   ' Using pin group 48 (P48-P55)

    ' Test modes
    TEST_FRAME_RATE = 1
    TEST_QUEUE_PERFORMANCE = 2
    TEST_SENSOR_DATA = 3

OBJ
    tile_sensor     : "tile_sensor"         ' Magnetic tile sensor interface
    frame_queue     : "frame_queue"         ' Frame buffer queue

VAR { test variables }

    LONG    test_mode
    LONG    frame_stats[5]                  ' Performance statistics
    LONG    queue_stats[4]                  ' Queue statistics
    LONG    test_duration                   ' Test duration in seconds

PUB main() | success, frame_ptr, test_frames, start_time
'' Main entry point for magnetic imaging tile test system
'' @returns nothing - runs complete test suite and displays results

    ' Initialize system
    debug("P2 Magnetic Imaging Tile Test System")
    debug("=====================================")

    ' Start frame queue
    success := frame_queue.start()
    if not success
        debug("ERROR: Failed to start frame queue")
        return

    debug("Frame queue started successfully")

    ' Start tile sensor
    success := tile_sensor.start(SENSOR_PIN_GROUP, @frame_queue)
    if not success
        debug("ERROR: Failed to start tile sensor")
        return

    debug("Tile sensor started on pin group ", udec(SENSOR_PIN_GROUP))

    ' Run tests
    test_frame_rate_limits()
    test_queue_performance()
    test_sensor_data_quality()

    ' Cleanup
    tile_sensor.stop()
    frame_queue.stop()

    debug("Test complete")

PRI test_frame_rate_limits() | test_rates[5], i, rate
'' Test various frame rates to determine system performance limits
'' @returns nothing - outputs test results via debug statements

    debug("")
    debug("=== FRAME RATE PERFORMANCE TEST ===")

    ' Test different frame rates
    test_rates[0] := 100
    test_rates[1] := 500
    test_rates[2] := 1000
    test_rates[3] := 1500
    test_rates[4] := 2000

    repeat i from 0 to 4
        rate := test_rates[i]
        debug("Testing ", udec(rate), " Hz...")

        ' Set target frame rate
        tile_sensor.set_frame_rate_target(rate)
        tile_sensor.set_acquisition_mode(2)    ' High-speed mode

        ' Run for 5 seconds
        waitms(5000)

        ' Get performance statistics
        tile_sensor.get_performance_stats(@frame_stats)

        debug("  Target: ", udec(rate), " Hz")
        debug("  Actual: ", udec(frame_stats[2]), " Hz")
        debug("  Frames: ", udec(frame_stats[0]))
        debug("  Errors: ", udec(frame_stats[1]))

        ' Stop acquisition between tests
        tile_sensor.set_acquisition_mode(0)
        waitms(1000)

    debug("Frame rate test complete")

PRI test_queue_performance() | i, frames_processed
'' Test frame queue performance under high-speed acquisition conditions
'' @returns nothing - monitors and reports queue statistics

    debug("")
    debug("=== QUEUE PERFORMANCE TEST ===")

    ' Start high-speed acquisition
    tile_sensor.set_frame_rate_target(1000)
    tile_sensor.set_acquisition_mode(2)

    ' Monitor queue for 10 seconds
    repeat i from 0 to 19
        waitms(500)

        ' Get queue statistics
        frame_queue.get_queue_stats(@queue_stats)

        debug("Queue depth: ", udec(queue_stats[0]), "/32")
        debug("Dropped: ", udec(queue_stats[1]))
        debug("Total: ", udec(queue_stats[2]))
        debug("Utilization: ", udec(queue_stats[3]), "%")
        debug("---")

    ' Stop acquisition
    tile_sensor.set_acquisition_mode(0)

    debug("Queue performance test complete")

PRI test_sensor_data_quality() | frame_ptr, i, sensor_val, min_val, max_val, avg_val
'' Test sensor data quality by analyzing captured frame statistics
'' @returns nothing - analyzes and reports sensor data ranges

    debug("")
    debug("=== SENSOR DATA QUALITY TEST ===")

    ' Start live acquisition
    tile_sensor.set_acquisition_mode(1)
    waitms(1000)                            ' Let it stabilize

    ' Analyze several frames
    repeat i from 0 to 9
        ' Get a frame from queue
        frame_ptr := frame_queue.dequeue_frame()

        if frame_ptr <> 0
            ' Analyze frame data
            analyze_frame_data(frame_ptr, @min_val, @max_val, @avg_val)

            debug("Frame ", udec(i + 1), ":")
            debug("  Min: ", udec(min_val))
            debug("  Max: ", udec(max_val))
            debug("  Avg: ", udec(avg_val))
            debug("  Range: ", udec(max_val - min_val))

            ' Release frame
            frame_queue.release_frame()
        else
            debug("No frame available")

        waitms(100)

    ' Stop acquisition
    tile_sensor.set_acquisition_mode(0)

    debug("Sensor data quality test complete")

PRI analyze_frame_data(frame_ptr, min_ptr, max_ptr, avg_ptr) | i, val, sum, min_val, max_val
'' Analyze frame data to extract minimum, maximum, and average sensor values
'' @param frame_ptr - pointer to frame buffer containing 64 sensor readings
'' @param min_ptr - pointer to store minimum value found
'' @param max_ptr - pointer to store maximum value found
'' @param avg_ptr - pointer to store calculated average value
'' @returns nothing - stores results in provided pointer locations

    ' Initialize values
    min_val := $FFFF
    max_val := 0
    sum := 0

    ' Analyze all 64 sensors in frame
    repeat i from 0 to 63
        val := WORD[frame_ptr + (i * 2)]     ' Read word value

        if val < min_val
            min_val := val
        if val > max_val
            max_val := val

        sum += val

    ' Store results
    LONG[min_ptr] := min_val
    LONG[max_ptr] := max_val
    LONG[avg_ptr] := sum / 64

PRI debug_frame_layout(frame_ptr) | row, col, val
'' Display frame data in 8x8 grid format for visual inspection
'' @param frame_ptr - pointer to frame buffer containing 64 sensor readings
'' @returns nothing - outputs formatted grid via debug statements

    debug("Frame Data Layout (8x8):")
    debug("========================")

    repeat row from 0 to 7
        debug("Row ", udec(row), ": ", end)
        repeat col from 0 to 7
            val := WORD[frame_ptr + ((row * 8 + col) * 2)]
            debug(uhex_word(val), " ", end)
        debug("")

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}