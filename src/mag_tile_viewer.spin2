' mag_tile_viewer - Main Application
' Magnetic Field Imaging Tile Viewer for P2 Edge with PSRAM
'
' Pin Assignments:
'   P0-P7:   HDMI Display
'   P8-P15:  Magnetic Tile Sensor (8 x 8 grid, SPI, + 2pins)
'   P16-P23: OLED Display (128 x 128 SPI)
'   P40-P57: PSRAM (P2 Edge)

CON
  _CLKFREQ = 250_000_000   ' 250 MHz for HDMI timing

  ' System modes
  TEST_MODE = false         ' true = generate test patterns, no decimation
                           ' false = normal operation with real sensor data
  SLOW_SCAN_MODE = true    ' true = one scan every SLOW_SCAN_MS (for sensor testing)
                           ' false = normal high-speed operation
  SLOW_SCAN_MS = 250       ' Delay between scans in slow mode (250ms = 4 fps for testing)

  ADC_VERIFY_MODE = false  ' true = run ADC verification (2 scans, log values, then stop)
                           ' false = normal operation
                           ' NOTE: When true, overrides TEST_MODE and SLOW_SCAN_MODE

  AUTO_CALIBRATE = true    ' true = capture baseline at startup (removes per-sensor variation)
                           ' false = skip calibration (raw sensor values, may show banding)
                           ' NOTE: For accurate calibration, remove all magnets before starting!

  LOG_SENSOR_VALUES = false ' true = log sensor values to debug output (verbose!)
                           ' false = suppress sensor value logging for cleaner output

  ' Pin group assignments
  HDMI_BASE_PIN   = 0
  SENSOR_BASE_PIN = 8
  OLED_BASE_PIN   = 16

OBJ
  ' Core system components
  fifo       : "isp_frame_fifo_manager"      ' Multi-FIFO frame pool manager

  ' Display engines
  hdmi_engine : "isp_hdmi_display_engine"    ' HDMI display consumer (owns gfx)
  oled        : "isp_oled_single_cog"        ' OLED single-COG driver (replaces old multi-COG stack)

  ' Data acquisition
  sensor      : "isp_tile_sensor"            ' Magnetic tile sensor interface

VAR
  LONG  system_status

  ' Decimation state (integrated into main COG)
  LONG  processing_mode
  LONG  hdmi_decimation
  LONG  oled_decimation
  LONG  frame_counter
  LONG  hdmi_counter
  LONG  oled_counter

CON { decimation constants }

  ' Default decimation ratios @ 250 MHz system clock
  ' Sensor runs at ~375 fps, HDMI at 60 fps, OLED at ~55 fps (measured)
  DEFAULT_HDMI_DECIMATION = 6    ' Every 6th frame to HDMI (375/6 = 62.5 fps)
  DEFAULT_OLED_DECIMATION = 7    ' Every 7th frame to OLED (375/7 = 53.6 fps, OLED max ~55 fps)

  ' Processing modes
  MODE_DECIMATION = 0            ' Simple frame skipping
  MODE_AVERAGING  = 1            ' Average multiple frames
  MODE_PEAK       = 2            ' Peak detection across frames

PUB main() | success

  debug("Starting Magnetic Tile Viewer", 13, 10)
  debug("============================", 13, 10)

  ' Initialize the frame FIFO manager
  debug("Initializing frame FIFO manager...", 13, 10)
  if not fifo.start()
    debug("ERROR: Failed to start FIFO manager", 13, 10)
    return

  ' Start HDMI display engine (owns graphics system)
  debug("Starting HDMI display engine (P0-P7)...", 13, 10)
  if hdmi_engine.start(HDMI_BASE_PIN) < 0
    debug("ERROR: Failed to start HDMI engine", 13, 10)
    return
  debug("  HDMI engine ready", 13, 10)

  ' Start OLED single-COG driver (P16-P23) with orientation
  debug("Starting OLED single-COG driver (ribbon LEFT)...", 13, 10)
  if not oled.start(OLED_BASE_PIN, oled.ORIENTATION_90)
    debug("ERROR: Failed to start OLED driver", 13, 10)
    return
  debug("  OLED driver ready (ORIENTATION_90, ribbon LEFT)", 13, 10)

  ' Initialize decimation state (integrated into main COG)
  debug("Initializing decimation in main COG...", 13, 10)
  processing_mode := MODE_DECIMATION
  frame_counter := 0
  hdmi_counter := 0
  oled_counter := 0

  ' Configure decimation based on test mode
  if TEST_MODE
    hdmi_decimation := 1  ' Send EVERY frame to HDMI
    oled_decimation := 1  ' Send EVERY frame to OLED
    debug("  Decimation in TEST MODE - 1:1 (no decimation)", 13, 10)
  elseif SLOW_SCAN_MODE
    hdmi_decimation := 1  ' Send every captured frame to HDMI
    oled_decimation := 1  ' Send every captured frame to OLED
    debug("  SLOW SCAN MODE - one scan every ", udec(SLOW_SCAN_MS/1000), " seconds", 13, 10)
  else
    hdmi_decimation := DEFAULT_HDMI_DECIMATION
    oled_decimation := DEFAULT_OLED_DECIMATION
    debug("  Decimation in NORMAL mode - HDMI ", udec(hdmi_decimation), ":1, OLED ", udec(oled_decimation), ":1", 13, 10)

  ' Start sensor interface (with ptra save/restore fix applied)
  debug("Starting sensor interface (P8-P15)...", 13, 10)
  if not sensor.start(SENSOR_BASE_PIN)  ' sensor only takes base_pin parameter
    debug("ERROR: Failed to start sensor interface", 13, 10)
    return
  else
    debug("  Sensor interface ready", 13, 10)

    ' Set acquisition mode based on mode flags
    ' ADC_VERIFY_MODE takes priority over other modes
    if ADC_VERIFY_MODE
      sensor.set_acquisition_mode(sensor.MODE_ADC_VERIFY)
      debug("  Sensor set to ADC VERIFY mode (2 scans then stop)", 13, 10)
    elseif TEST_MODE
      sensor.set_acquisition_mode(sensor.MODE_TEST_PATTERN)
      debug("  Sensor set to TEST PATTERN mode", 13, 10)
    else
      sensor.set_acquisition_mode(sensor.MODE_LIVE)
      debug("  Sensor set to LIVE mode", 13, 10)

  ' Perform per-sensor baseline calibration (optional)
  ' This eliminates manufacturing variation between sensors that causes "banding" artifacts
  if AUTO_CALIBRATE
    debug(" ", 13, 10)
    debug("****************************************", 13, 10)
    debug("*         CALIBRATION MODE             *", 13, 10)
    debug("*    REMOVE ALL MAGNETS FROM SENSOR    *", 13, 10)
    debug("****************************************", 13, 10)
    debug(" ", 13, 10)
    debug("Calibrating in: 5...", 13, 10)
    waitms(1000)
    debug("Calibrating in: 4...", 13, 10)
    waitms(1000)
    debug("Calibrating in: 3...", 13, 10)
    waitms(1000)
    debug("Calibrating in: 2...", 13, 10)
    waitms(1000)
    debug("Calibrating in: 1...", 13, 10)
    waitms(1000)
    debug(">>> CAPTURING BASELINE NOW <<<", 13, 10)
    if sensor.capture_baseline()
      debug("Calibration SUCCESS", 13, 10)
      ' Report stuck pixel summary
      if sensor.get_stuck_count() > 0
        debug(" ", 13, 10)
        debug("*** STUCK PIXELS: ", udec(sensor.get_stuck_count()), " ***", 13, 10)
        debug("*** These will display as MAGENTA ***", 13, 10)
    else
      debug("Calibration FAILED - using raw values", 13, 10)
    debug(" ", 13, 10)

  debug("****************************************", 13, 10)
  debug("*            SYSTEM LIVE               *", 13, 10)
  debug("*     MAGNET CAN NOW BE PLACED         *", 13, 10)
  debug("****************************************", 13, 10)
  debug(" ", 13, 10)

  ' Main decimation loop (runs in main COG)
  decimation_loop()

PRI decimation_loop() | framePtr, sendHDMI, sendOLED, hdmiPtr, oledPtr, drained
'' Main decimation loop running in main COG
'' Dequeues frames from sensor FIFO, applies decimation, routes to display FIFOs

  debug("Main COG: Decimation loop started", 13, 10)

  if SLOW_SCAN_MODE
    ' SLOW SCAN MODE: One frame every N seconds for sensor debugging
    slow_scan_loop()
  else
    ' NORMAL MODE: High-speed decimation
    normal_decimation_loop()

PRI slow_scan_loop() | framePtr, hdmiPtr, oledPtr, drained, i
'' Slow scan mode: One frame every SLOW_SCAN_MS milliseconds
'' Used for sensor debugging - allows visual inspection of each reading

  debug("Main COG: SLOW SCAN MODE active", 13, 10)

  repeat
    ' Wait for a frame from sensor FIFO
    framePtr := fifo.dequeue(fifo.FIFO_SENSOR)

    if framePtr
      frame_counter++
      debug("SLOW SCAN: Frame ", udec(frame_counter), " acquired", 13, 10)

      ' WATCHPOINT: Check for corruption after sensor dequeue
      if fifo.checkFreeListIntegrity() >= 0
        debug("*** CORRUPTION DETECTED AFTER SENSOR DEQUEUE ***", 13, 10)

      ' Print sensor values for debugging (controlled by LOG_SENSOR_VALUES)
      if LOG_SENSOR_VALUES
        debug("Sensor data (calibrated 16-bit values):", 13, 10)
        repeat i from 0 to 7
          debug("  Row ", udec(i), ": ")
          debug(udec(WORD[framePtr][i*8+0]), " ")
          debug(udec(WORD[framePtr][i*8+1]), " ")
          debug(udec(WORD[framePtr][i*8+2]), " ")
          debug(udec(WORD[framePtr][i*8+3]), " ")
          debug(udec(WORD[framePtr][i*8+4]), " ")
          debug(udec(WORD[framePtr][i*8+5]), " ")
          debug(udec(WORD[framePtr][i*8+6]), " ")
          debug(udec(WORD[framePtr][i*8+7]), 13, 10)

      ' Send to HDMI display
      hdmiPtr := fifo.getNextFrame()
      ' WATCHPOINT: Check after HDMI getNextFrame
      if fifo.checkFreeListIntegrity() >= 0
        debug("*** CORRUPTION AFTER HDMI getNextFrame ***", 13, 10)
      if hdmiPtr
        WORDMOVE(hdmiPtr, framePtr, 64)
        if fifo.commitFrame(fifo.FIFO_HDMI, hdmiPtr) < 0
          fifo.releaseFrame(hdmiPtr)
          ' WATCHPOINT: Check after HDMI releaseFrame (error path)
          if fifo.checkFreeListIntegrity() >= 0
            debug("*** CORRUPTION AFTER HDMI releaseFrame (err) ***", 13, 10)
        ' WATCHPOINT: Check after HDMI commit/release
        if fifo.checkFreeListIntegrity() >= 0
          debug("*** CORRUPTION AFTER HDMI commit ***", 13, 10)

      ' Send to OLED display
      oledPtr := fifo.getNextFrame()
      ' WATCHPOINT: Check after OLED getNextFrame
      if fifo.checkFreeListIntegrity() >= 0
        debug("*** CORRUPTION AFTER OLED getNextFrame ***", 13, 10)
      if oledPtr
        WORDMOVE(oledPtr, framePtr, 64)
        if fifo.commitFrame(fifo.FIFO_OLED, oledPtr) < 0
          fifo.releaseFrame(oledPtr)
          ' WATCHPOINT: Check after OLED releaseFrame (error path)
          if fifo.checkFreeListIntegrity() >= 0
            debug("*** CORRUPTION AFTER OLED releaseFrame (err) ***", 13, 10)
        ' WATCHPOINT: Check after OLED commit/release
        if fifo.checkFreeListIntegrity() >= 0
          debug("*** CORRUPTION AFTER OLED commit ***", 13, 10)

      ' Release original frame
      fifo.releaseFrame(framePtr)
      ' WATCHPOINT: Check after releasing original sensor frame
      if fifo.checkFreeListIntegrity() >= 0
        debug("*** CORRUPTION AFTER SENSOR releaseFrame ***", 13, 10)

      ' WATCHPOINT: Check before drain loop
      if fifo.checkFreeListIntegrity() >= 0
        debug("*** CORRUPTION BEFORE DRAIN LOOP ***", 13, 10)

      ' Drain any remaining frames from sensor FIFO (keep it fresh)
      ' Limit to 32 frames max to avoid infinite loop (sensor produces continuously)
      drained := 0
      repeat 32
        framePtr := fifo.dequeue(fifo.FIFO_SENSOR)
        if framePtr == 0
          quit
        fifo.releaseFrame(framePtr)
        drained++
        ' WATCHPOINT: Check after each drain release
        if fifo.checkFreeListIntegrity() >= 0
          debug("*** CORRUPTION DURING DRAIN (after ", udec(drained), " frames) ***", 13, 10)
      if drained > 0
        debug("  (drained ", udec(drained), " stale frames)", 13, 10)

      ' WATCHPOINT: Final check after drain complete
      if fifo.checkFreeListIntegrity() >= 0
        debug("*** CORRUPTION AFTER DRAIN COMPLETE ***", 13, 10)

      ' Wait before next scan
      debug("Waiting ", udec(SLOW_SCAN_MS/1000), " seconds...", 13, 10)
      WAITMS(SLOW_SCAN_MS)

PRI normal_decimation_loop() | framePtr, sendHDMI, sendOLED, hdmiPtr, oledPtr
'' Normal high-speed decimation loop

  repeat
    ' Wait for frame from sensor FIFO
    framePtr := fifo.dequeue(fifo.FIFO_SENSOR)

    if framePtr
      ' Update frame counter
      frame_counter++

      ' Debug every 30 frames (every 0.5 sec at 60fps)
      if (frame_counter // 30) == 1
        debug("MAIN: Frame ", udec(frame_counter), " depths S:", udec(fifo.getQueueDepth(fifo.FIFO_SENSOR)))
        debug(" H:", udec(fifo.getQueueDepth(fifo.FIFO_HDMI)))
        debug(" O:", udec(fifo.getQueueDepth(fifo.FIFO_OLED)))
        debug(" F:", udec(fifo.getFreeFrames()), 13, 10)

      ' Process frame based on mode
      case processing_mode
        MODE_DECIMATION:
          ' Simple decimation - pass through selected frames
          ' ALWAYS send first frame to both displays for immediate feedback
          hdmi_counter++
          oled_counter++
          sendHDMI := (frame_counter == 1) or (hdmi_counter // hdmi_decimation) == 0
          sendOLED := (frame_counter == 1) or (oled_counter // oled_decimation) == 0

        MODE_AVERAGING:
          ' TODO: Implement frame averaging
          hdmi_counter++
          oled_counter++
          sendHDMI := (frame_counter == 1) or (hdmi_counter // hdmi_decimation) == 0
          sendOLED := (frame_counter == 1) or (oled_counter // oled_decimation) == 0

        MODE_PEAK:
          ' TODO: Implement peak detection
          hdmi_counter++
          oled_counter++
          sendHDMI := (frame_counter == 1) or (hdmi_counter // hdmi_decimation) == 0
          sendOLED := (frame_counter == 1) or (oled_counter // oled_decimation) == 0

      ' Route to appropriate display FIFOs
      ' Note: Independent checks allow frame to go to BOTH displays
      ' Each display gets its own copy to prevent ownership conflicts

      if sendHDMI
        hdmiPtr := fifo.getNextFrame()
        if hdmiPtr
          WORDMOVE(hdmiPtr, framePtr, 64)  ' Copy 64 words (128 bytes)
          if fifo.commitFrame(fifo.FIFO_HDMI, hdmiPtr) < 0
            ' HDMI FIFO full, release the copy
            fifo.releaseFrame(hdmiPtr)

      if sendOLED
        oledPtr := fifo.getNextFrame()
        if oledPtr
          WORDMOVE(oledPtr, framePtr, 64)  ' Copy 64 words (128 bytes)
          if fifo.commitFrame(fifo.FIFO_OLED, oledPtr) < 0
            ' OLED FIFO full, release the copy
            fifo.releaseFrame(oledPtr)

      ' Always release the original sensor frame
      fifo.releaseFrame(framePtr)
