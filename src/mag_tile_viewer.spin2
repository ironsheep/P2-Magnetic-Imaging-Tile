' mag_tile_viewer - Main Application
' Magnetic Field Imaging Tile Viewer for P2 Edge with PSRAM
'
' Pin Assignments:
'   P0-P7:   HDMI Display
'   P8-P15:  Magnetic Tile Sensor (8 x 8 grid, SPI, + 2pins)
'   P16-P23: OLED Display (128 x 128 SPI)
'   P40-P57: PSRAM (P2 Edge)

CON
  _CLKFREQ = 250_000_000   ' 250 MHz for HDMI timing

  ' System modes
  TEST_MODE = true         ' true = generate test patterns, no decimation
                           ' false = normal operation with real sensor data

  ' Pin group assignments
  HDMI_BASE_PIN   = 0
  SENSOR_BASE_PIN = 8
  OLED_BASE_PIN   = 16

OBJ
  ' Core system components
  fifo       : "isp_frame_fifo_manager"      ' Multi-FIFO frame pool manager

  ' Display engines
  hdmi_engine : "isp_hdmi_display_engine"    ' HDMI display consumer (owns gfx)
  oled        : "isp_oled_single_cog"        ' OLED single-COG driver (replaces old multi-COG stack)

  ' Data acquisition
  sensor      : "isp_tile_sensor"            ' Magnetic tile sensor interface

VAR
  LONG  system_status

  ' Decimation state (integrated into main COG)
  LONG  processing_mode
  LONG  hdmi_decimation
  LONG  oled_decimation
  LONG  frame_counter
  LONG  hdmi_counter
  LONG  oled_counter

CON { decimation constants }

  ' Default decimation ratios
  DEFAULT_HDMI_DECIMATION = 9    ' Every 9th frame to HDMI
  DEFAULT_OLED_DECIMATION = 27   ' Every 27th frame to OLED

  ' Processing modes
  MODE_DECIMATION = 0            ' Simple frame skipping
  MODE_AVERAGING  = 1            ' Average multiple frames
  MODE_PEAK       = 2            ' Peak detection across frames

PUB main() | success

  debug("Starting Magnetic Tile Viewer", 13, 10)
  debug("============================", 13, 10)

  ' Initialize the frame FIFO manager
  debug("Initializing frame FIFO manager...", 13, 10)
  if not fifo.start()
    debug("ERROR: Failed to start FIFO manager", 13, 10)
    return

  ' Start HDMI display engine (owns graphics system)
  debug("Starting HDMI display engine (P0-P7)...", 13, 10)
  if hdmi_engine.start(HDMI_BASE_PIN) < 0
    debug("ERROR: Failed to start HDMI engine", 13, 10)
    return
  debug("  HDMI engine ready", 13, 10)

  ' Start OLED single-COG driver (P16-P23) with orientation
  debug("Starting OLED single-COG driver (ribbon LEFT)...", 13, 10)
  if not oled.start(OLED_BASE_PIN, oled.ORIENTATION_270)
    debug("ERROR: Failed to start OLED driver", 13, 10)
    return
  debug("  OLED driver ready (270 deg orientation)", 13, 10)

  ' Initialize decimation state (integrated into main COG)
  debug("Initializing decimation in main COG...", 13, 10)
  processing_mode := MODE_DECIMATION
  frame_counter := 0
  hdmi_counter := 0
  oled_counter := 0

  ' Configure decimation based on test mode
  if TEST_MODE
    hdmi_decimation := 1  ' Send EVERY frame to HDMI
    oled_decimation := 1  ' Send EVERY frame to OLED
    debug("  Decimation in TEST MODE - 1:1 (no decimation)", 13, 10)
  else
    hdmi_decimation := DEFAULT_HDMI_DECIMATION
    oled_decimation := DEFAULT_OLED_DECIMATION
    debug("  Decimation in NORMAL mode - HDMI ", udec(hdmi_decimation), ":1, OLED ", udec(oled_decimation), ":1", 13, 10)

  ' Start sensor interface
  debug("Starting sensor interface (P8-P15)...", 13, 10)
  if not sensor.start(SENSOR_BASE_PIN)  ' sensor only takes base_pin parameter
    debug("ERROR: Failed to start sensor interface", 13, 10)
    return
  else
    debug("  Sensor interface ready", 13, 10)

    ' Set acquisition mode based on TEST_MODE
    if TEST_MODE
      sensor.set_acquisition_mode(sensor.MODE_TEST_PATTERN)
      debug("  Sensor set to TEST PATTERN mode", 13, 10)
    else
      sensor.set_acquisition_mode(sensor.MODE_LIVE)
      debug("  Sensor set to LIVE mode", 13, 10)

  debug(" ", 13, 10)
  debug("System initialization complete!", 13, 10)
  debug(" ", 13, 10)
  debug("=== PIPELINE ACTIVE ===", 13, 10)
  debug("Data flow: Sensor -> Sensor FIFO -> Main COG (decimator) -> HDMI/OLED FIFOs", 13, 10)
  debug(" ", 13, 10)

  ' Main decimation loop (runs in main COG)
  decimation_loop()

PRI decimation_loop() | framePtr, sendHDMI, sendOLED, hdmiPtr, oledPtr
'' Main decimation loop running in main COG
'' Dequeues frames from sensor FIFO, applies decimation, routes to display FIFOs

  debug("Main COG: Decimation loop started", 13, 10)

  repeat
    ' Wait for frame from sensor FIFO
    debug("Main COG: [DEQ] Waiting for frame from SENSOR FIFO...", 13, 10)
    framePtr := fifo.dequeue(fifo.FIFO_SENSOR)
    debug("Main COG: [DEQ] Got frame from SENSOR FIFO, ptr=", uhex_long(framePtr), 13, 10)

    if framePtr
      ' Update frame counter
      frame_counter++

      ' Debug every 30 frames (every 0.5 sec at 60fps)
      if (frame_counter // 30) == 1
        debug("Main COG: Frame ", udec(frame_counter), " from sensor (ptr=", uhex_long(framePtr), ")", 13, 10)
        debug("  FIFO depths - Sensor: ", udec(fifo.getQueueDepth(fifo.FIFO_SENSOR)))
        debug(", HDMI: ", udec(fifo.getQueueDepth(fifo.FIFO_HDMI)))
        debug(", OLED: ", udec(fifo.getQueueDepth(fifo.FIFO_OLED)))
        debug(", Free: ", udec(fifo.getFreeFrames()), 13, 10)
        debug("  Display frames - HDMI: ", udec(hdmi_engine.get_frame_count()))
        debug(", OLED: ", udec(oled.get_frame_count()), 13, 10)

      ' Process frame based on mode
      case processing_mode
        MODE_DECIMATION:
          ' Simple decimation - pass through selected frames
          hdmi_counter++
          oled_counter++
          sendHDMI := (hdmi_counter // hdmi_decimation) == 0
          sendOLED := (oled_counter // oled_decimation) == 0

        MODE_AVERAGING:
          ' TODO: Implement frame averaging
          hdmi_counter++
          oled_counter++
          sendHDMI := (hdmi_counter // hdmi_decimation) == 0
          sendOLED := (oled_counter // oled_decimation) == 0

        MODE_PEAK:
          ' TODO: Implement peak detection
          hdmi_counter++
          oled_counter++
          sendHDMI := (hdmi_counter // hdmi_decimation) == 0
          sendOLED := (oled_counter // oled_decimation) == 0

      ' Route to appropriate display FIFOs
      ' Note: Independent checks allow frame to go to BOTH displays
      ' Each display gets its own copy to prevent ownership conflicts

      if sendHDMI
        hdmiPtr := fifo.getNextFrame()
        if hdmiPtr
          WORDMOVE(hdmiPtr, framePtr, 64)  ' Copy 64 words (128 bytes)
          debug("Main COG: [ENQ] Committing to HDMI FIFO, ptr=", uhex_long(hdmiPtr), 13, 10)
          if fifo.commitFrame(fifo.FIFO_HDMI, hdmiPtr) < 0
            ' HDMI FIFO full, release the copy
            debug("Main COG: [ENQ] HDMI FIFO FULL! Releasing", 13, 10)
            fifo.releaseFrame(hdmiPtr)
          else
            debug("Main COG: [ENQ] HDMI committed (frame ", udec(frame_counter), ")", 13, 10)

      if sendOLED
        oledPtr := fifo.getNextFrame()
        if oledPtr
          WORDMOVE(oledPtr, framePtr, 64)  ' Copy 64 words (128 bytes)
          debug("Main COG: [ENQ] Committing to OLED FIFO, ptr=", uhex_long(oledPtr), 13, 10)
          if fifo.commitFrame(fifo.FIFO_OLED, oledPtr) < 0
            ' OLED FIFO full, release the copy
            debug("Main COG: [ENQ] OLED FIFO FULL! Releasing", 13, 10)
            fifo.releaseFrame(oledPtr)
          else
            debug("Main COG: [ENQ] OLED committed (frame ", udec(frame_counter), ")", 13, 10)

      ' Always release the original sensor frame
      fifo.releaseFrame(framePtr)
