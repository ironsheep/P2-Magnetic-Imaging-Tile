'' isp_oled_manager.spin2 - OLED Display Manager
'' Consumes frames from OLED FIFO and displays via OLED driver
''
'' This COG:
''   - Dequeues frames from OLED FIFO
''   - Converts sensor data to OLED format
''   - Manages OLED display updates

CON
  ' Test mode configuration
  TEST_MODE   = false     ' true = show test pattern, false = process FIFO

  ' OLED display dimensions
  OLED_WIDTH  = 128
  OLED_HEIGHT = 128

  ' Sensor display configuration
  SENSOR_GRID_SIZE = 8
  CELL_WIDTH  = OLED_WIDTH / SENSOR_GRID_SIZE    ' 16 pixels per cell
  CELL_HEIGHT = OLED_HEIGHT / SENSOR_GRID_SIZE   ' 16 pixels per cell

  ' Display update modes
  MODE_FULL_UPDATE = 0
  MODE_DIFFERENTIAL = 1

  ' FIFO IDs (must match isp_frame_fifo_manager)
  FIFO_OLED   = 2

  ' Color mapping ranges
  MIN_FIELD   = 0         ' Minimum field value
  MAX_FIELD   = 4095      ' Maximum field value (12-bit from sensor)
  MID_FIELD   = 2048      ' Neutral field value (12-bit midpoint)

  ' Display orientation constants (pass-through to driver)
  ' Use these when mounting OLED in different orientations
  ORIENTATION_0   = 0  ' Ribbon at BOTTOM (standard/default)
  ORIENTATION_90  = 1  ' Ribbon at RIGHT (rotated 90° clockwise)
  ORIENTATION_180 = 2  ' Ribbon at TOP (upside down)
  ORIENTATION_270 = 3  ' Ribbon at LEFT (rotated 90° counter-clockwise)

OBJ
  fifo : "isp_frame_fifo_manager"
  oled : "isp_oled_driver"

VAR
  long  cog_id
  long  frame_count
  long  update_mode
  long  base_pin
  word  last_frame[64]    ' Previous frame for differential updates
  byte  frame_buffer[OLED_WIDTH * OLED_HEIGHT * 2]  ' OLED display buffer (RGB565)

  ' COG stack (64 longs per P2KB recommendations)
  long  oled_cog_stack[64]

PUB null()
  '' Not a top-level object

PUB start(oled_base_pin) : ok
  '' Start the OLED manager
  '' @param oled_base_pin - base pin for OLED SPI interface
  '' @returns cog_id if successful, -1 if failed

  debug("OLED Manager: Starting...", 13, 10)

  ' Initialize COG ID FIRST (critical - must be set before calling stop()!)
  cog_id := -1

  stop()

  ' Save pin configuration
  base_pin := oled_base_pin

  ' Initialize OLED driver
  debug("OLED Manager: Calling driver start()...", 13, 10)
  if not oled.start(base_pin)
    debug("OLED Manager: ERROR - Driver start() failed!", 13, 10)
    return -1

  debug("OLED Manager: Driver initialized successfully", 13, 10)

  ' Clear last frame buffer
  wordfill(@last_frame, 0, 64)

  ' Initialize variables
  frame_count := 0
  update_mode := MODE_FULL_UPDATE

  debug("OLED Manager: Starting display COG...", 13, 10)
  ' Start display COG
  cog_id := cogspin(NEWCOG, oled_loop(), @oled_cog_stack)

  if cog_id < 0
    debug("OLED Manager: ERROR - Failed to start COG!", 13, 10)
  else
    debug("OLED Manager: COG ", udec(cog_id), " started successfully", 13, 10)

  return cog_id

PUB stop()
  '' Stop the OLED manager

  ' Validate COG ID is in valid range (0-7) before stopping
  if cog_id >= 0 and cog_id <= 7
    cogstop(cog_id)
    oled.stop()
  cog_id := -1

PUB set_update_mode(mode)
  '' Set display update mode
  '' @param mode - MODE_FULL_UPDATE or MODE_DIFFERENTIAL

  update_mode := mode

PUB get_frame_count() : count
  '' Get number of frames displayed

  return frame_count

PUB set_orientation(new_orientation)
  '' Set display orientation (pass-through to driver)
  '' @param new_orientation - ORIENTATION_0, ORIENTATION_90, ORIENTATION_180, or ORIENTATION_270
  '' Call this after start() to configure orientation for panel mounting

  oled.set_orientation(new_orientation)

PUB get_orientation() : current
  '' Get current display orientation (pass-through to driver)
  '' @returns current orientation (0-3)

  return oled.get_orientation()

PUB show_test_pattern() | row, col, sensorVal, pattern
  '' Display a test pattern directly (bypasses FIFO)
  '' Useful for initial testing without full pipeline

  debug("OLED Test Pattern: Building checkerboard pattern...", 13, 10)

  ' Create a checkerboard pattern with gradient (12-bit values)
  repeat row from 0 to 7
    repeat col from 0 to 7
      ' Create alternating pattern with gradient
      if (row + col) & 1
        pattern := (row * 512) + (col * 256)  ' Diagonal gradient (12-bit)
      else
        pattern := 4095 - ((row * 512) + (col * 256))  ' Inverse gradient (12-bit)

      ' Build display buffer with test pattern
      build_test_cell(row, col, pattern)

  debug("OLED Test Pattern: Pattern built, clearing display...", 13, 10)
  ' Send to OLED
  oled.clear()

  debug("OLED Test Pattern: Sending bitmap (", udec(OLED_WIDTH * OLED_HEIGHT * 2), " bytes)...", 13, 10)
  oled.draw_bitmap(0, 0, OLED_WIDTH, OLED_HEIGHT, @frame_buffer)

  debug("OLED Test Pattern: Display complete!", 13, 10)

PRI build_test_cell(row, col, value) | color, x, y, pixelIdx
  '' Build a single cell in the frame buffer for test pattern
  '' @param row, col - cell position (0-7)
  '' @param value - test value to display

  ' Convert to RGB565 color
  color := field_to_rgb565(value)

  ' Fill the cell in display buffer
  repeat y from 0 to CELL_HEIGHT - 1
    repeat x from 0 to CELL_WIDTH - 1
      pixelIdx := ((row * CELL_HEIGHT + y) * OLED_WIDTH + (col * CELL_WIDTH + x)) * 2
      frame_buffer[pixelIdx] := color & $FF
      frame_buffer[pixelIdx + 1] := color >> 8

PRI oled_loop() | framePtr, row, col, sensorVal, color, idx, changed
  '' Main OLED display loop running in dedicated COG

  debug("OLED Loop: COG started, TEST_MODE=", udec(TEST_MODE), 13, 10)

  if TEST_MODE
    ' Test pattern mode - display once and idle
    debug("OLED Loop: Displaying test pattern...", 13, 10)
    show_test_pattern()
    debug("OLED Loop: Entering idle loop (test pattern should be visible)", 13, 10)
    repeat
      waitms(1000)  ' Just keep COG alive
  else
    ' Normal operation - process FIFO
    debug("OLED Loop: FIFO processing mode active", 13, 10)

    ' Register this COG as OLED FIFO consumer for event-driven wake-ups
    fifo.registerConsumer(FIFO_OLED, cogid())
    debug("OLED Loop: Registered COG ", udec(cogid()), " for event-driven dequeue", 13, 10)

    ' Clear display initially
    oled.clear()

    repeat
      ' Event-driven dequeue: sleeps until producer sends COGATN
      ' Zero jitter, zero power while waiting
      framePtr := fifo.dequeueEventDriven(FIFO_OLED)

      if framePtr <> 0
        ' Log first frame received
        if frame_count == 0
          debug("OLED Manager: First frame received! (ptr=", uhex_long(framePtr), ")", 13, 10)

        ' Check if frame has changed (for differential mode)
        changed := false
        if update_mode == MODE_DIFFERENTIAL
          repeat idx from 0 to 63
            if word[framePtr][idx] <> last_frame[idx]
              changed := true
              quit

        ' Increment frame counter
        frame_count++

        ' Debug output every 60 frames (~1 second at 60 fps)
        if (frame_count // 60) == 0
          debug("OLED Manager: Processed ", udec(frame_count), " frames", 13, 10)
          debug("  Corner values: TL=", udec(word[framePtr][0]), " TR=", udec(word[framePtr][7]), " BL=", udec(word[framePtr][56]), " BR=", udec(word[framePtr][63]), 13, 10)

        ' Update display if changed or in full update mode
        if changed or (update_mode == MODE_FULL_UPDATE)
          ' Draw sensor data directly using draw_rect() (avoids streaming COG)
          draw_sensor_grid(framePtr)

          ' Save frame for differential comparison
          wordmove(@last_frame, framePtr, 64)

        ' Release frame back to pool
        fifo.releaseFrame(framePtr)
      else
        ' FIFO timeout - shouldn't happen in normal operation
        debug("OLED Manager: FIFO dequeue timeout!", 13, 10)
        waitms(10)

PRI draw_sensor_grid(framePtr) | row, col, sensorIdx, sensorVal, color, x_pos, y_pos
  '' Draw sensor grid directly to OLED using draw_rect() (avoids streaming COG hang)
  '' @param framePtr - pointer to sensor frame data

  ' Process each sensor cell and draw directly
  repeat row from 0 to 7
    repeat col from 0 to 7
      ' Get sensor value
      sensorIdx := row * 8 + col
      sensorVal := word[framePtr][sensorIdx]

      ' Convert to RGB565 color
      color := field_to_rgb565(sensorVal)

      ' Calculate cell position
      x_pos := col * CELL_WIDTH
      y_pos := row * CELL_HEIGHT

      ' Draw filled rectangle for this cell using Spin2 bit-bang (works!)
      oled.draw_rect(x_pos, y_pos, CELL_WIDTH, CELL_HEIGHT, color)

PRI build_display_buffer(framePtr) | row, col, sensorIdx, sensorVal, color, x, y, pixelIdx
  '' Convert sensor frame to OLED display buffer (LEGACY - for test pattern only)
  '' @param framePtr - pointer to sensor frame data
  '' NOTE: This builds a buffer for draw_bitmap() which hangs. Use draw_sensor_grid() instead.

  ' Process each sensor
  repeat row from 0 to 7
    repeat col from 0 to 7
      ' Get sensor value
      sensorIdx := row * 8 + col
      sensorVal := word[framePtr][sensorIdx]

      ' Convert to RGB565 color
      color := field_to_rgb565(sensorVal)

      ' Fill the cell in display buffer
      repeat y from 0 to CELL_HEIGHT - 1
        repeat x from 0 to CELL_WIDTH - 1
          pixelIdx := ((row * CELL_HEIGHT + y) * OLED_WIDTH + (col * CELL_WIDTH + x)) * 2
          ' Store RGB565 color (little-endian)
          frame_buffer[pixelIdx] := color & $FF
          frame_buffer[pixelIdx + 1] := color >> 8

PRI field_to_rgb565(fieldVal) : color | r, g, b
  '' Convert magnetic field value to RGB565 color
  '' @param fieldVal - 12-bit sensor reading (0-4095)
  '' @returns RGB565 color value

  ' Color mapping for 12-bit range: Blue (low) -> Green (mid) -> Red (high)
  ' Thresholds: 1024 (1/4), 2048 (mid), 3072 (3/4)

  if fieldVal < 1024  ' Lower quarter - blue dominant
    b := 31
    g := fieldVal >> 4  ' 0-31 range (divide by 32)
    r := 0
  elseif fieldVal < 2048  ' Mid-low - cyan to green
    b := 31 - ((fieldVal - 1024) >> 4)
    g := 31
    r := 0
  elseif fieldVal < 3072  ' Mid-high - green to yellow
    b := 0
    g := 31
    r := (fieldVal - 2048) >> 5  ' 0-31 range (divide by 32)
  else  ' Upper quarter - red dominant
    b := 0
    g := 31 - ((fieldVal - 3072) >> 4)
    r := 31

  ' Convert to RGB565 format: RRRRRGGG GGGBBBBB
  color := (r << 11) | (g << 6) | b

  return color