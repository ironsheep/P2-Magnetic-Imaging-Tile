'' =================================================================================================
''   File....... isp_oled_single_cog.spin2
''   Purpose.... Single-COG OLED driver with integrated FIFO management
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Jan 2025
''
'' =================================================================================================
''
'' Consolidated single-COG OLED solution that combines:
''   - FIFO frame dequeue and management
''   - Sensor data to color conversion (8x8 grid)
''   - Direct SPI transmission to 128x128 OLED display
''
'' Hardware: 128x128 SPI OLED (SSD1351 controller)
'' Pin connections (fixed pins):
''   P16: MOSI - SPI Data
''   P18: SCLK - SPI Clock
''   P20: CS   - Chip Select
''   P22: DC   - Data/Command
''   P23: RST  - Reset
''
'' Display: 8x8 sensor grid scaled to 128x128 pixels (16x16 pixels per cell)
''
'' =================================================================================================

CON
  ' Pin offsets from base pin (non-consecutive group)
  OFFSET_MOSI = 0   ' Base + 0 = MOSI - Smart Pin SYNC_TX
  OFFSET_SCLK = 2   ' Base + 2 = SCLK - Smart Pin PULSE
  OFFSET_CS   = 4   ' Base + 4 = CS - GPIO
  OFFSET_DC   = 6   ' Base + 6 = DC - GPIO
  OFFSET_RST  = 7   ' Base + 7 = RST - GPIO

  ' SPI timing
  SPI_FREQ = 20_000_000   ' 20 MHz SPI clock (maximum per datasheet)

  ' Display dimensions
  WIDTH  = 128
  HEIGHT = 128

  ' Display coordinate offsets (adjust if display is shifted)
  ' NOTE: Offsets apply to physical display coordinates after orientation transformation
  COLUMN_OFFSET = 0    ' No horizontal offset
  ROW_OFFSET = -32     ' Shift left by 2 cells (2 * 16 pixels) - hardware characteristic

  ' Sensor grid configuration
  SENSOR_GRID_SIZE = 8
  CELL_WIDTH  = WIDTH / SENSOR_GRID_SIZE    ' 16 pixels per cell
  CELL_HEIGHT = HEIGHT / SENSOR_GRID_SIZE   ' 16 pixels per cell

  ' Display orientation (based on ribbon connector position)
  ORIENTATION_0   = 0  ' Ribbon at BOTTOM (hardware default)
  ORIENTATION_90  = 1  ' Ribbon at LEFT (display rotated 90° clockwise)
  ORIENTATION_180 = 2  ' Ribbon at TOP (display rotated 180°)
  ORIENTATION_270 = 3  ' Ribbon at RIGHT (display rotated 270° clockwise)

  DEFAULT_ORIENTATION = ORIENTATION_90  ' Ribbon LEFT (your hardware configuration)

  ' SSD1351 OLED commands (subset needed for operation)
  CMD_SET_COLUMN      = $15  ' Set Column Address
  CMD_SET_ROW         = $75  ' Set Row Address
  CMD_WRITE_RAM       = $5C  ' Write RAM Command
  CMD_SET_REMAP       = $A0  ' Set Re-map & Color Depth
  CMD_START_LINE      = $A1  ' Set Display Start Line
  CMD_DISPLAY_OFFSET  = $A2  ' Set Display Offset
  CMD_NORMAL_DISPLAY  = $A6  ' Normal Display
  CMD_FUNCTION_SEL    = $AB  ' Function Selection
  CMD_DISPLAY_OFF     = $AE  ' Sleep Mode ON (Display OFF)
  CMD_DISPLAY_ON      = $AF  ' Sleep Mode OFF (Display ON)
  CMD_PRECHARGE       = $B1  ' Set Phase Length
  CMD_ENHANCEDISPLAY  = $B2  ' Display Enhancement
  CMD_CLOCKDIV        = $B3  ' Set Front Clock Divider
  CMD_SET_VSL         = $B4  ' Set Segment Low Voltage
  CMD_SET_GPIO        = $B5  ' Set GPIO
  CMD_PRECHARGE2      = $B6  ' Set Second Precharge Period
  CMD_LINEAR_LUT      = $B9  ' Use Built-in Linear LUT
  CMD_PRECHARGE_V     = $BB  ' Set Pre-charge Voltage
  CMD_VCOMH           = $BE  ' Set VCOMH Voltage
  CMD_CONTRAST        = $C1  ' Set Contrast Current
  CMD_MASTER_CONTRAST = $C7  ' Master Contrast Current Control
  CMD_MUX_RATIO       = $CA  ' Set MUX Ratio
  CMD_COMMAND_LOCK    = $FD  ' Set Command Lock

  ' Color mapping ranges
  MIN_FIELD   = 0         ' Minimum field value
  MAX_FIELD   = 4095      ' Maximum field value (12-bit from sensor)
  MID_FIELD   = 2048      ' Neutral field value (12-bit midpoint)

OBJ
  fifo : "isp_frame_fifo_manager"

VAR
  LONG  cog_id            ' COG ID (-1 = not running)
  LONG  frame_count       ' Total frames displayed
  LONG  orientation       ' Current display orientation (0-3)
  LONG  base_pin          ' Base pin for OLED interface

  ' Frame timing measurements (in system clock cycles)
  LONG  last_frame_cycles ' Cycles taken for last frame display
  LONG  min_frame_cycles  ' Minimum cycles observed
  LONG  max_frame_cycles  ' Maximum cycles observed
  LONG  total_frames_timed ' Number of frames included in timing stats

  ' Calculated pin numbers (set during init based on base_pin)
  LONG  pin_mosi
  LONG  pin_sclk
  LONG  pin_cs
  LONG  pin_dc
  LONG  pin_rst

  ' Pre-rendered pixel buffer for fast display (128x128 RGB565 = 32KB)
  WORD  pixel_buffer[16384]

  ' Color lookup table for sensor values (4096 entries = 8KB)
  ' Maps 12-bit sensor values directly to RGB565 colors
  WORD  color_lut[4096]

  ' COG stack (64 longs per P2KB recommendations)
  LONG  display_cog_stack[64]

DAT
  ' Remap register values for each orientation (Corrected mapping - Nov 2025)
  ' Bit 2=0 (RGB mode) because software already converts to BGR565
  ' Mapping ensures (0,0) appears at correct corner for each ribbon position
  remap_values  BYTE  $73   ' ORIENTATION_0: Ribbon BOTTOM, (0,0) at bottom-left
                BYTE  $72   ' ORIENTATION_90: Ribbon LEFT, (0,0) at top-left
                BYTE  $70   ' ORIENTATION_180: Ribbon TOP, (0,0) at top-right
                BYTE  $71   ' ORIENTATION_270: Ribbon RIGHT, (0,0) at bottom-right

PUB null()
'' This is not a top-level object
'' @returns nothing - placeholder method for non-top-level object
  cog_id := -1

PUB init(oled_base_pin) : success
'' Initialize OLED hardware ONLY (no background COG)
'' Use this for driver testing with display_frame()
'' @param oled_base_pin - base pin for OLED interface (typically 16)
'' @returns TRUE if successful

  cog_id := -1
  frame_count := 0
  orientation := DEFAULT_ORIENTATION
  base_pin := oled_base_pin

  ' Calculate pin numbers from base
  pin_mosi := base_pin + OFFSET_MOSI
  pin_sclk := base_pin + OFFSET_SCLK
  pin_cs   := base_pin + OFFSET_CS
  pin_dc   := base_pin + OFFSET_DC
  pin_rst  := base_pin + OFFSET_RST

  debug("OLED: Initializing hardware on pin group ", udec(base_pin), "...", 13, 10)
  init_hardware()
  init_color_lut()
  debug("OLED: Hardware ready", 13, 10)

  return TRUE

PUB start(oled_base_pin, oled_orientation) : success
'' Start the single-COG OLED driver with integrated FIFO management
'' @param oled_base_pin - base pin for OLED interface (typically 16)
'' @param oled_orientation - display orientation (0-3), use ORIENTATION_* constants
'' @returns TRUE if successful, FALSE if failed to start

  ' CRITICAL: Initialize cog_id first (defaults to 0, needs to be -1)
  if cog_id == 0
    cog_id := -1

  if cog_id >= 0
    return TRUE  ' Already running

  ' Initialize variables
  frame_count := 0
  orientation := oled_orientation   ' Set orientation BEFORE launching COG
  base_pin := oled_base_pin

  ' Calculate pin numbers from base
  pin_mosi := base_pin + OFFSET_MOSI
  pin_sclk := base_pin + OFFSET_SCLK
  pin_cs   := base_pin + OFFSET_CS
  pin_dc   := base_pin + OFFSET_DC
  pin_rst  := base_pin + OFFSET_RST

  debug("OLED Single-COG: Starting on pin group ", udec(base_pin), "...", 13, 10)

  ' Start background COG - it will initialize its own hardware
  debug("OLED Single-COG: Launching display COG...", 13, 10)
  cog_id := cogspin(NEWCOG, display_loop(), @display_cog_stack)

  if cog_id < 0
    debug("OLED Single-COG: ERROR - COG failed to start!", 13, 10)
    return FALSE

  debug("OLED Single-COG: COG ", udec(cog_id), " started successfully", 13, 10)
  return TRUE

PUB stop()
'' Stop the OLED driver and terminate background cog operation
'' @returns nothing - stops all operations

  if cog_id >= 0 and cog_id <= 7
    cogstop(cog_id)
    cog_id := -1

PUB set_orientation(new_orientation)
'' Set display orientation for panel mounting flexibility
'' @param new_orientation - ORIENTATION_0 (0), ORIENTATION_90 (1), ORIENTATION_180 (2), or ORIENTATION_270 (3)
'' @returns nothing - updates display orientation

  if new_orientation >= 0 and new_orientation <= 3
    orientation := new_orientation

PUB get_frame_count() : count
'' Get total number of frames displayed
'' @returns frame count as LONG

  return frame_count

PUB get_timing_stats(last_us_ptr, min_us_ptr, max_us_ptr, avg_us_ptr) | avg_cycles
'' Get frame timing statistics
'' @param last_us_ptr - pointer to receive last frame time in microseconds
'' @param min_us_ptr - pointer to receive minimum frame time in microseconds
'' @param max_us_ptr - pointer to receive maximum frame time in microseconds
'' @param avg_us_ptr - pointer to receive average frame time in microseconds
'' @returns nothing - writes statistics to provided pointers

  if last_us_ptr
    LONG[last_us_ptr] := last_frame_cycles / 250
  if min_us_ptr
    LONG[min_us_ptr] := min_frame_cycles / 250
  if max_us_ptr
    LONG[max_us_ptr] := max_frame_cycles / 250
  if avg_us_ptr
    ' Note: Could add running average if needed, for now just return last
    LONG[avg_us_ptr] := last_frame_cycles / 250

PUB display_frame(framePtr) | row, col, sensor_idx, value, color, x, y, px, py, start_cycles, end_cycles, elapsed_cycles
'' Display a single frame to OLED (for testing - no FIFO, no background COG)
'' @param framePtr - pointer to 64-WORD sensor frame buffer
'' @returns nothing - renders frame and returns immediately
''
'' USE THIS FOR DRIVER TESTING - bypasses all FIFO/COG complexity

  ' Start timing measurement
  start_cycles := GETCT()

  ' Render 8x8 sensor grid to 128x128 display
  ' Each sensor cell = 16x16 pixels
  repeat row from 0 to 7
    repeat col from 0 to 7
      ' Calculate sensor index in frame buffer
      sensor_idx := (row * 8) + col

      ' Read sensor value (WORD)
      value := WORD[framePtr][sensor_idx]

      ' Convert sensor value to color
      color := value_to_color(value, MIN_FIELD, MAX_FIELD)

      ' Calculate pixel position with orientation-specific coordinate transformation
      transform_coordinates(row, col, @x, @y)

      ' Set drawing window for this cell (16x16 pixels)
      set_window(x, y, x + CELL_WIDTH - 1, y + CELL_HEIGHT - 1)

      ' Fill cell with color (16x16 = 256 pixels)
      ' Keep CS/DC asserted for entire block (efficient streaming)
      PINLOW(pin_cs)      ' Select display
      PINHIGH(pin_dc)     ' Data mode

      ' Send pixels in row-major order (row by row, not column by column)
      ' Optimize: send color bytes with minimal waiting
      repeat 256  ' 16x16 pixels, unrolled loop
        spi_write_fast(color >> 8)
        spi_write_fast(color & $FF)

      ' Wait for final byte to complete before deasserting CS
      repeat until PINR(pin_sclk)
      PINHIGH(pin_cs)     ' Deselect after entire block

  ' End timing measurement and update statistics
  end_cycles := GETCT()
  elapsed_cycles := end_cycles - start_cycles
  last_frame_cycles := elapsed_cycles

  ' Update min/max statistics
  if total_frames_timed == 0
    min_frame_cycles := elapsed_cycles
    max_frame_cycles := elapsed_cycles
  else
    if elapsed_cycles < min_frame_cycles
      min_frame_cycles := elapsed_cycles
    if elapsed_cycles > max_frame_cycles
      max_frame_cycles := elapsed_cycles

  total_frames_timed++

  ' Report timing after 6th frame (for test programs that only display 6 frames)
  if total_frames_timed == 6
    ' Calculate timing in microseconds and frames per second
    ' At 250 MHz: 1 cycle = 4 ns, so cycles / 250 = microseconds
    debug("OLED: Frame timing summary (6 frames)", 13, 10)
    debug("  Last: ", udec(elapsed_cycles / 250), " us = ", udec(250_000_000 / elapsed_cycles), " fps", 13, 10)
    debug("  Min: ", udec(min_frame_cycles / 250), " us = ", udec(250_000_000 / min_frame_cycles), " fps", 13, 10)
    debug("  Max: ", udec(max_frame_cycles / 250), " us = ", udec(250_000_000 / max_frame_cycles), " fps", 13, 10)

PUB display_frame_fast(framePtr) | start_cycles, end_cycles, elapsed_cycles
'' Display a frame using optimized two-phase approach:
''   Phase 1: Pre-render sensor data to 128x128 pixel buffer (Spin2)
''   Phase 2: Stream entire buffer to display via PASM with events
'' @param framePtr - pointer to 64-WORD sensor frame buffer
'' @returns nothing - renders frame and returns immediately

  ' Start timing measurement
  start_cycles := GETCT()

  ' Phase 1: Pre-render sensor data to pixel buffer
  ' All color conversion and coordinate transformation happens here
  render_to_pixel_buffer(framePtr)

  ' Phase 2: Set full-screen window and stream all pixels via PASM
  set_window(0, 0, WIDTH - 1, HEIGHT - 1)
  stream_pixel_buffer()

  ' End timing measurement and update statistics
  end_cycles := GETCT()
  elapsed_cycles := end_cycles - start_cycles
  last_frame_cycles := elapsed_cycles

  ' Update min/max statistics
  if total_frames_timed == 0
    min_frame_cycles := elapsed_cycles
    max_frame_cycles := elapsed_cycles
  else
    if elapsed_cycles < min_frame_cycles
      min_frame_cycles := elapsed_cycles
    if elapsed_cycles > max_frame_cycles
      max_frame_cycles := elapsed_cycles

  total_frames_timed++

PRI render_to_pixel_buffer(framePtr) | row, col, sensor_idx, value, color, px, py, cell_row, row_ptr, lut_ptr
'' Pre-render sensor frame to 128x128 pixel buffer with all transformations
'' @param framePtr - pointer to 64-WORD sensor frame buffer
'' @returns nothing - fills pixel_buffer with RGB565 data ready for streaming
''
'' Optimized: Uses color LUT lookup and WORDFILL for fast rendering

  lut_ptr := @color_lut

  ' Process each sensor cell (8x8 = 64 cells)
  repeat row from 0 to 7
    repeat col from 0 to 7
      ' Read sensor value and clamp to 12-bit range
      sensor_idx := (row * 8) + col
      value := WORD[framePtr][sensor_idx]
      value := 0 #> value <# 4095

      ' Lookup color directly from LUT (no math!)
      color := WORD[lut_ptr][value]

      ' Calculate pixel buffer position based on orientation
      ' Each sensor cell is 16x16 pixels
      get_cell_origin(row, col, @px, @py)

      ' Fill 16x16 pixel block using WORDFILL for each row (16 pixels at a time)
      repeat cell_row from 0 to 15
        row_ptr := @pixel_buffer[((py + cell_row) * WIDTH) + px]
        WORDFILL(row_ptr, color, 16)

PRI get_cell_origin(row, col, px_ptr, py_ptr) | temp_row, temp_col, px, py
'' Calculate pixel buffer origin for a sensor cell based on orientation
'' @param row - sensor row (0-7)
'' @param col - sensor column (0-7)
'' @param px_ptr - pointer to receive x pixel coordinate
'' @param py_ptr - pointer to receive y pixel coordinate
'' @returns nothing - writes coordinates to pointers

  ' Stage 1: Transform from sensor layout to display-normal layout
  ' Sensor data appears rotated 90 left and horizontally mirrored
  temp_row := col
  temp_col := row

  ' Stage 2: Apply orientation-specific transformations
  case orientation
    ORIENTATION_0:
      ' Ribbon BOTTOM
      px := (7 - temp_col) * CELL_WIDTH
      py := temp_row * CELL_HEIGHT

    ORIENTATION_90:
      ' Ribbon LEFT (default)
      px := (7 - temp_col) * CELL_WIDTH
      py := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_180:
      ' Ribbon TOP
      px := (7 - temp_col) * CELL_WIDTH
      py := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_270:
      ' Ribbon RIGHT
      px := (7 - temp_col) * CELL_WIDTH
      py := temp_row * CELL_HEIGHT

  LONG[px_ptr] := px
  LONG[py_ptr] := py

PRI stream_pixel_buffer() | buf_ptr, pixel_count, mosi_pin, sclk_pin, cs_pin, dc_pin, pixel_val, byte_val
'' Stream entire pixel buffer to OLED via inline PASM with events
'' Uses waitse1 for efficient waiting instead of polling
'' @returns nothing - transmits all 32,768 bytes to display

  ' Copy pin numbers to local variables for PASM access
  buf_ptr := @pixel_buffer
  pixel_count := 16384
  mosi_pin := pin_mosi
  sclk_pin := pin_sclk
  cs_pin := pin_cs
  dc_pin := pin_dc

  ' Stream all pixels using inline PASM
  ORG
        ' Configure event for SCLK IN flag (signals transfer complete)
        ' Event encoding: %01 = IN rise, pin number in lower 6 bits
        mov     pa, sclk_pin
        or      pa, #%01_000000
        setse1  pa

        ' Assert CS and DC for data mode
        drvl    cs_pin                  ' CS low - select display
        drvh    dc_pin                  ' DC high - data mode

        ' Set up pixel counter and buffer pointer
        mov     ptra, buf_ptr
        mov     pb, pixel_count

.pixel_loop
        ' Read next RGB565 pixel from buffer
        rdword  pixel_val, ptra++

        ' === Send high byte ===
        mov     byte_val, pixel_val
        shr     byte_val, #8
        and     byte_val, #$FF
        ' Bit-reverse for MSB-first transmission
        shl     byte_val, #24           ' Move byte to bits 31:24
        rev     byte_val                ' Reverse all 32 bits
        ' Load data and trigger clock
        wypin   byte_val, mosi_pin      ' Load reversed byte
        wypin   #8, sclk_pin            ' Generate 8 clock pulses
        ' Wait for transfer complete using event (COG halts efficiently)
        waitse1

        ' === Send low byte ===
        mov     byte_val, pixel_val
        and     byte_val, #$FF
        ' Bit-reverse for MSB-first transmission
        shl     byte_val, #24           ' Move byte to bits 31:24
        rev     byte_val                ' Reverse all 32 bits
        ' Load data and trigger clock
        wypin   byte_val, mosi_pin      ' Load reversed byte
        wypin   #8, sclk_pin            ' Generate 8 clock pulses
        ' Wait for transfer complete using event (COG halts efficiently)
        waitse1

        ' Loop until all pixels sent
        djnz    pb, #.pixel_loop

        ' Deassert CS
        drvh    cs_pin                  ' CS high - deselect display

  END

PRI init_hardware() | clk_period, temp, i
'' Initialize OLED hardware (GPIO pins, Smart Pins, display controller)
'' @returns nothing - performs hardware setup

  debug("OLED Single-COG: Initializing hardware...", 13, 10)

  ' Configure GPIO pins (CS, DC, RST)
  PINHIGH(pin_cs)    ' CS high (deselected)
  PINLOW(pin_dc)     ' DC low (default to command mode)
  PINHIGH(pin_rst)   ' RST high (not in reset)

  ' Calculate clock period for desired SPI frequency
  clk_period := 2 #> (CLKFREQ / SPI_FREQ) <# $FFFF

  debug("  Clock period: ", udec(clk_period), " ticks for ", udec(SPI_FREQ), " Hz", 13, 10)

  ' Configure SCLK as pulse mode for clock generation (copied from working driver)
  PINSTART(pin_sclk, P_OE | P_PULSE, clk_period | (clk_period >> 1) << 16, 0)

  ' Configure MOSI as Sync Serial TX mode (copied from working driver)
  ' Add clock pin offset in bits 24-26
  PINSTART(pin_mosi, P_OE | P_SYNC_TX | ((pin_sclk - pin_mosi) & %111) << 24, %1_00000 | 7, 0)

  ' Hardware reset sequence
  debug("  Performing hardware reset...", 13, 10)
  PINLOW(pin_rst)
  WAITMS(10)
  PINHIGH(pin_rst)
  WAITMS(10)

  ' Initialize display controller
  debug("  Initializing SSD1351 controller...", 13, 10)
  init_display()

  debug("  Hardware initialization complete", 13, 10)

PRI init_color_lut() | i, normalized, r, g, b, color
'' Build color lookup table mapping 12-bit sensor values to RGB565 colors
'' Full resolution: each of 4096 sensor values gets unique color
'' Color gradient: Blue (cold) -> Green (neutral) -> Red (hot)

  debug("  Building color LUT (4096 entries)...", 13, 10)

  repeat i from 0 to 4095
    ' Normalize to 0-511 range (full 12-bit resolution, scaled for color calc)
    ' Use 512 steps to get smooth gradient across full range
    normalized := (i * 511) / 4095

    ' Bipolar color mapping with full resolution
    if normalized < 256
      ' Blue to Green (cold to neutral): 0-255
      r := 0
      g := normalized                     ' 0 -> 255
      b := 255 - normalized               ' 255 -> 0
    else
      ' Green to Red (neutral to hot): 256-511
      r := normalized - 256               ' 0 -> 255
      g := 511 - normalized               ' 255 -> 0
      b := 0

    ' Convert 8-bit RGB to 5-6-5 BGR565 format (SSD1351 expects BGR)
    color := ((b >> 3) << 11) | ((g >> 2) << 5) | (r >> 3)
    color_lut[i] := color

  debug("  Color LUT ready", 13, 10)

PRI init_display()
'' Initialize SSD1351 OLED controller with optimized settings
'' @returns nothing - sends initialization command sequence

  ' Command lock - unlock normal commands
  send_command(CMD_COMMAND_LOCK)
  send_data($12)

  ' Display off during configuration
  send_command(CMD_DISPLAY_OFF)

  ' Clock divider - Fosc=1, divider=1 (fastest)
  send_command(CMD_CLOCKDIV)
  send_data($F1)

  ' MUX ratio - 128 rows
  send_command(CMD_MUX_RATIO)
  send_data($7F)

  ' Set remap and color depth based on orientation
  send_command(CMD_SET_REMAP)
  send_data(BYTE[@remap_values][orientation])
  send_data($00)

  ' Start line
  send_command(CMD_START_LINE)
  send_data($00)

  ' Display offset
  send_command(CMD_DISPLAY_OFFSET)
  send_data($00)

  ' Set GPIO
  send_command(CMD_SET_GPIO)
  send_data($00)

  ' Function selection
  send_command(CMD_FUNCTION_SEL)
  send_data($01)

  ' Precharge period
  send_command(CMD_PRECHARGE)
  send_data($32)

  ' VCOMH voltage
  send_command(CMD_VCOMH)
  send_data($05)

  ' Normal display mode
  send_command(CMD_NORMAL_DISPLAY)

  ' Contrast settings (R, G, B)
  send_command(CMD_CONTRAST)
  send_data($C8)  ' Color A (Red)
  send_data($80)  ' Color B (Green)
  send_data($C8)  ' Color C (Blue)

  ' Master contrast
  send_command(CMD_MASTER_CONTRAST)
  send_data($0F)

  ' Linear grayscale LUT
  send_command(CMD_LINEAR_LUT)

  ' Precharge voltage
  send_command(CMD_PRECHARGE_V)
  send_data($17)

  ' Second precharge period
  send_command(CMD_PRECHARGE2)
  send_data($01)

  ' VSL
  send_command(CMD_SET_VSL)
  send_data($A0)
  send_data($B5)
  send_data($55)

  ' Display enhancement
  send_command(CMD_ENHANCEDISPLAY)
  send_data($A4)
  send_data($00)
  send_data($00)

  ' Display ON
  send_command(CMD_DISPLAY_ON)

  WAITMS(100)

PRI send_command(cmd)
'' Send command byte to OLED controller (COPIED FROM WORKING DRIVER)
'' @param cmd - command byte

  PINLOW(pin_cs)   ' Select display
  PINLOW(pin_dc)   ' Command mode
  spi_write(cmd)
  PINHIGH(pin_cs)  ' Deselect after command

PRI send_data(data)
'' Send data byte to OLED controller (COPIED FROM WORKING DRIVER)
'' @param data - data byte

  PINLOW(pin_cs)   ' Select display
  PINHIGH(pin_dc)  ' Data mode
  spi_write(data)
  PINHIGH(pin_cs)  ' Deselect after data

PRI spi_write(value) | reversed
'' Send byte via Smart Pin SPI using inline REV instruction
'' @param value - byte to send

  ' Bit-reverse the value inline (replaces LUT lookup)
  reversed := (value & $FF) << 24
  reversed REV= 31

  ' Load bit-reversed value
  WYPIN(pin_mosi, reversed)

  ' Trigger 8 clock pulses
  WYPIN(pin_sclk, 8)

  ' Wait for transmission complete
  repeat until PINR(pin_sclk)

PRI spi_write_fast(value) | reversed
'' Send byte via Smart Pin SPI - OPTIMIZED (no wait between consecutive bytes)
'' @param value - byte to send
'' NOTE: Caller must wait for final transmission to complete

  ' Wait for previous transmission to complete before loading new data
  repeat until PINR(pin_sclk)

  ' Bit-reverse the value inline (replaces LUT lookup)
  reversed := (value & $FF) << 24
  reversed REV= 31

  ' Load bit-reversed value
  WYPIN(pin_mosi, reversed)

  ' Trigger 8 clock pulses
  WYPIN(pin_sclk, 8)

  ' Return immediately without waiting - allows pipelining

PRI set_window(x1, y1, x2, y2)
'' Set active drawing window on OLED display
'' @param x1 - starting column (0-127)
'' @param y1 - starting row (0-127)
'' @param x2 - ending column (0-127)
'' @param y2 - ending row (0-127)
'' @returns nothing - configures drawing area

  send_command(CMD_SET_COLUMN)
  send_data(x1 + COLUMN_OFFSET)
  send_data(x2 + COLUMN_OFFSET)

  send_command(CMD_SET_ROW)
  send_data(y1 + ROW_OFFSET)
  send_data(y2 + ROW_OFFSET)

  send_command(CMD_WRITE_RAM)

PRI transform_coordinates(row, col, x_ptr, y_ptr) | x, y, temp_row, temp_col
'' Transform buffer coordinates (row, col) to display coordinates (x, y) based on orientation
'' @param row - buffer row (0-7)
'' @param col - buffer column (0-7)
'' @param x_ptr - pointer to x coordinate output
'' @param y_ptr - pointer to y coordinate output
'' @returns nothing - writes x, y to pointers
''
'' Two-stage transformation:
''   Stage 1: Sensor layout to display layout (rotate 90° right + un-mirror)
''   Stage 2: Orientation-specific positioning based on ribbon location

  ' STAGE 1: Transform from sensor data layout to display-normal layout
  ' Sensor data appears rotated 90° left and horizontally mirrored relative to display
  ' So we rotate 90° right and un-mirror to normalize
  temp_row := col          ' Rotate 90° right: old col becomes new row (no inversion)
  temp_col := row          ' Rotate 90° right: old row becomes new col (no inversion)

  ' STAGE 2: Apply orientation-specific transformations
  ' These position the normalized data correctly based on ribbon location
  case orientation
    ORIENTATION_0:
      ' Ribbon BOTTOM: Away from ribbon, left side
      x := (7 - temp_col) * CELL_WIDTH
      y := temp_row * CELL_HEIGHT

    ORIENTATION_90:
      ' Ribbon LEFT: Next to ribbon, left side
      x := (7 - temp_col) * CELL_WIDTH
      y := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_180:
      ' Ribbon TOP: Next to ribbon, right side
      x := (7 - temp_col) * CELL_WIDTH
      y := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_270:
      ' Ribbon RIGHT: Away from ribbon, right side
      x := (7 - temp_col) * CELL_WIDTH
      y := temp_row * CELL_HEIGHT

  ' Write results to output pointers
  LONG[x_ptr] := x
  LONG[y_ptr] := y

PRI value_to_color(value, min_val, max_val) : color | range, normalized, r, g, b
'' Convert sensor value to RGB565 color using bipolar color mapping
'' @param value - sensor value
'' @param min_val - minimum expected value
'' @param max_val - maximum expected value
'' @returns RGB565 color (16-bit)
''
'' Color mapping:
''   Below midpoint -> Blue (cold)
''   At midpoint -> Green (neutral)
''   Above midpoint -> Red (hot)

  range := max_val - min_val
  if range == 0
    return $07E0  ' Green if no range

  ' Normalize to 0-255 range
  normalized := ((value - min_val) * 255) / range
  normalized := 0 #> normalized <# 255

  ' Bipolar color mapping
  if normalized < 128
    ' Blue to Green (cold to neutral)
    r := 0
    g := (normalized * 2)
    b := 255 - (normalized * 2)
  else
    ' Green to Red (neutral to hot)
    r := ((normalized - 128) * 2)
    g := 255 - ((normalized - 128) * 2)
    b := 0

  ' Convert 8-bit RGB to 5-6-5 BGR565 format (SSD1351 expects BGR, not RGB)
  color := ((b >> 3) << 11) | ((g >> 2) << 5) | (r >> 3)

PRI display_loop() | framePtr
'' Background COG display loop - dequeues frames and renders to OLED
'' Runs in dedicated COG, integrates FIFO management and display rendering

  ' Background COG initializes its own hardware (owns its pins)
  debug("OLED Single-COG: Initializing hardware in background COG...", 13, 10)
  init_hardware()
  debug("OLED Single-COG: Display loop started", 13, 10)

  repeat
    ' Dequeue frame from OLED FIFO
    debug("OLED: [DEQ] Calling dequeue(FIFO_OLED)...", 13, 10)
    framePtr := fifo.dequeue(fifo.FIFO_OLED)
    debug("OLED: [DEQ] Returned from dequeue, ptr=", uhex_long(framePtr), 13, 10)

    if framePtr == 0
      ' No frame available, wait and retry
      debug("OLED: No frame (timeout), waiting 5ms...", 13, 10)
      WAITMS(5)
      next

    ' Display frame using the tested, working display_frame() method
    debug("OLED: Rendering frame with display_frame()...", 13, 10)
    display_frame(framePtr)

    ' Release frame back to pool
    debug("OLED: Releasing frame ptr=", uhex_long(framePtr), 13, 10)
    fifo.releaseFrame(framePtr)

    ' Increment frame count
    frame_count++
    debug("OLED: Frame ", udec(frame_count), " rendered", 13, 10)

PRI send_pixel_data(color)
'' Send RGB565 pixel data (2 bytes) to OLED via SPI (USES WORKING SPI CODE)
'' @param color - RGB565 color value (16-bit)
'' @returns nothing - transmits high byte then low byte

  ' Keep CS low for both bytes (efficient multi-byte transaction)
  PINLOW(pin_cs)      ' Select display
  PINHIGH(pin_dc)     ' Data mode

  ' Send high byte
  spi_write(color >> 8)

  ' Send low byte
  spi_write(color & $FF)

  PINHIGH(pin_cs)     ' Deselect after both bytes

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
