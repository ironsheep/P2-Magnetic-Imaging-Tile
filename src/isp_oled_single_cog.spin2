'' =================================================================================================
''   File....... isp_oled_single_cog.spin2
''   Purpose.... Single-COG OLED driver with integrated FIFO management
''   Author..... Stephen M Moraco
''               -- Copyright (c) 2025 Iron Sheep Productions, LLC
''               -- see below for terms of use
''   E-mail..... stephen@ironsheep.biz
''   Started.... Jan 2025
''   Updated.... Jan 2025
''
'' =================================================================================================
''
'' Consolidated single-COG OLED solution that combines:
''   - FIFO frame dequeue and management
''   - Sensor data to color conversion (8x8 grid)
''   - Direct SPI transmission to 128x128 OLED display
''
'' Hardware: 128x128 SPI OLED (SSD1351 controller)
'' Pin connections (fixed pins):
''   P16: MOSI - SPI Data
''   P18: SCLK - SPI Clock
''   P20: CS   - Chip Select
''   P22: DC   - Data/Command
''   P23: RST  - Reset
''
'' Display: 8x8 sensor grid scaled to 128x128 pixels (16x16 pixels per cell)
''
'' =================================================================================================

CON
  ' Pin offsets from base pin (non-consecutive group)
  OFFSET_MOSI = 0   ' Base + 0 = MOSI - Smart Pin SYNC_TX
  OFFSET_SCLK = 2   ' Base + 2 = SCLK - Smart Pin PULSE
  OFFSET_CS   = 4   ' Base + 4 = CS - GPIO
  OFFSET_DC   = 6   ' Base + 6 = DC - GPIO
  OFFSET_RST  = 7   ' Base + 7 = RST - GPIO

  ' SPI timing
  SPI_FREQ = 20_000_000   ' 20 MHz SPI clock (maximum per datasheet)

  ' Display dimensions
  WIDTH  = 128
  HEIGHT = 128

  ' Display coordinate offsets (adjust if display is shifted)
  ' NOTE: Offsets apply to physical display coordinates after orientation transformation
  COLUMN_OFFSET = 0    ' No horizontal offset
  ROW_OFFSET = -32     ' Shift left by 2 cells (2 * 16 pixels) - hardware characteristic

  ' Sensor grid configuration
  SENSOR_GRID_SIZE = 8
  CELL_WIDTH  = WIDTH / SENSOR_GRID_SIZE    ' 16 pixels per cell
  CELL_HEIGHT = HEIGHT / SENSOR_GRID_SIZE   ' 16 pixels per cell

  ' Sensor value calibration - FULL ADC RANGE
  ' See DOCs/MagSensor-Color-Mapping-Specification.md for details
  ' Uses full 16-bit ADC range to accommodate stronger magnets in future
  ' Baseline observed at ~20500, but map entire ADC range for future-proofing
  SENSOR_MIN = 0          ' ADC minimum (theoretical full negative saturation)
  SENSOR_MID = 20500      ' Zero field baseline (observed neutral point)
  SENSOR_MAX = 65535      ' ADC maximum (theoretical full positive saturation)
  SENSOR_RANGE = 65535    ' Full ADC range for LUT scaling
  NEGATIVE_RANGE = 20500  ' SENSOR_MID - SENSOR_MIN (0 to 20500)
  POSITIVE_RANGE = 45035  ' SENSOR_MAX - SENSOR_MID (20500 to 65535)
  GRAY_BASE = 32          ' Neutral gray intensity (dark gray background)

  ' Stuck pixel indicator color - bright magenta in BGR565 format (SSD1351)
  ' Distinct from red/green field colors, clearly indicates non-operational sensor
  ' BGR565: B=31 (5 bits), G=0 (6 bits), R=31 (5 bits)
  STUCK_PIXEL_COLOR = $F81F  ' Magenta: 11111_000000_11111

  ' Display orientation (based on ribbon connector position)
  ORIENTATION_0   = 0  ' Ribbon at BOTTOM (hardware default)
  ORIENTATION_90  = 1  ' Ribbon at LEFT (display rotated 90° clockwise)
  ORIENTATION_180 = 2  ' Ribbon at TOP (display rotated 180°)
  ORIENTATION_270 = 3  ' Ribbon at RIGHT (display rotated 270° clockwise)

  DEFAULT_ORIENTATION = ORIENTATION_90  ' Ribbon LEFT (your hardware configuration)

  ' SSD1351 OLED commands (subset needed for operation)
  CMD_SET_COLUMN      = $15  ' Set Column Address
  CMD_SET_ROW         = $75  ' Set Row Address
  CMD_WRITE_RAM       = $5C  ' Write RAM Command
  CMD_SET_REMAP       = $A0  ' Set Re-map & Color Depth
  CMD_START_LINE      = $A1  ' Set Display Start Line
  CMD_DISPLAY_OFFSET  = $A2  ' Set Display Offset
  CMD_NORMAL_DISPLAY  = $A6  ' Normal Display
  CMD_FUNCTION_SEL    = $AB  ' Function Selection
  CMD_DISPLAY_OFF     = $AE  ' Sleep Mode ON (Display OFF)
  CMD_DISPLAY_ON      = $AF  ' Sleep Mode OFF (Display ON)
  CMD_PRECHARGE       = $B1  ' Set Phase Length
  CMD_ENHANCEDISPLAY  = $B2  ' Display Enhancement
  CMD_CLOCKDIV        = $B3  ' Set Front Clock Divider
  CMD_SET_VSL         = $B4  ' Set Segment Low Voltage
  CMD_SET_GPIO        = $B5  ' Set GPIO
  CMD_PRECHARGE2      = $B6  ' Set Second Precharge Period
  CMD_LINEAR_LUT      = $B9  ' Use Built-in Linear LUT
  CMD_PRECHARGE_V     = $BB  ' Set Pre-charge Voltage
  CMD_VCOMH           = $BE  ' Set VCOMH Voltage
  CMD_CONTRAST        = $C1  ' Set Contrast Current
  CMD_MASTER_CONTRAST = $C7  ' Master Contrast Current Control
  CMD_MUX_RATIO       = $CA  ' Set MUX Ratio
  CMD_COMMAND_LOCK    = $FD  ' Set Command Lock

  ' Multi-resolution display modes (future: 8x8 → 16x16 → 32x32 interpolation)
  ' Sensor data always 8x8; interpolator expands for higher resolution display
  DISPLAY_MODE_8X8  = 0   ' Direct sensor values (64 cells)
  DISPLAY_MODE_16X16 = 1  ' 2x interpolated (256 cells)
  DISPLAY_MODE_32X32 = 2  ' 4x interpolated (1024 cells)

OBJ
  fifo : "isp_frame_fifo_manager"
  stack_check : "isp_stack_check"  ' Stack overflow detection utility
  sensor : "isp_tile_sensor"       ' Sensor interface (for stuck pixel detection)

CON { stack configuration }
  OLED_STACK_SIZE_LONGS = 128      ' Stack size for OLED display COG (increased from 64 - deep call chains)

VAR
  LONG  cog_id            ' COG ID (-1 = not running)
  LONG  frame_count       ' Total frames displayed
  LONG  orientation       ' Current display orientation (0-3)
  LONG  base_pin          ' Base pin for OLED interface

  ' Frame timing measurements (in system clock cycles)
  LONG  last_frame_cycles ' Cycles taken for last frame display
  LONG  min_frame_cycles  ' Minimum cycles observed
  LONG  max_frame_cycles  ' Maximum cycles observed
  LONG  total_frames_timed ' Number of frames included in timing stats

  ' Calculated pin numbers (set during init based on base_pin)
  LONG  pin_mosi
  LONG  pin_sclk
  LONG  pin_cs
  LONG  pin_dc
  LONG  pin_rst

  ' Pre-rendered pixel buffer for fast display (128x128 RGB565 = 32KB)
  WORD  pixel_buffer[16384]

  ' Color lookup table for sensor values (4096 entries = 8KB)
  ' Maps 12-bit sensor values directly to RGB565 colors
  WORD  color_lut[4096]

  ' Cell origin lookup table for fast rendering (64 entries for 8x8)
  ' Each entry is pixel buffer offset (WORD index) for cell's top-left corner
  ' Pre-computed at init based on orientation
  WORD  cell_origin_lut[64]

DAT { OLED display COG stack with overflow detection }
  ' Stack for OLED COG - placed in DAT with sentinel mark for overflow detection
  display_cog_stack   LONG    0[OLED_STACK_SIZE_LONGS]
  display_stack_mark  LONG    stack_check.DO_NOT_WRITE_MARK   ' Sentinel - overflow if overwritten

DAT
  ' Remap register values for each orientation (Corrected mapping - Nov 2025)
  ' Bit 2=0 (RGB mode) because software already converts to BGR565
  ' Mapping ensures (0,0) appears at correct corner for each ribbon position
  remap_values  BYTE  $73   ' ORIENTATION_0: Ribbon BOTTOM, (0,0) at bottom-left
                BYTE  $72   ' ORIENTATION_90: Ribbon LEFT, (0,0) at top-left
                BYTE  $70   ' ORIENTATION_180: Ribbon TOP, (0,0) at top-right
                BYTE  $71   ' ORIENTATION_270: Ribbon RIGHT, (0,0) at bottom-right

PUB null()
'' This is not a top-level object
'' @returns nothing - placeholder method for non-top-level object
  cog_id := -1

PUB init(oled_base_pin) : success
'' Initialize OLED hardware ONLY (no background COG)
'' Use this for driver testing with display_frame()
'' @param oled_base_pin - base pin for OLED interface (typically 16)
'' @returns TRUE if successful

  cog_id := -1
  frame_count := 0
  orientation := DEFAULT_ORIENTATION
  base_pin := oled_base_pin

  ' Calculate pin numbers from base
  pin_mosi := base_pin + OFFSET_MOSI
  pin_sclk := base_pin + OFFSET_SCLK
  pin_cs   := base_pin + OFFSET_CS
  pin_dc   := base_pin + OFFSET_DC
  pin_rst  := base_pin + OFFSET_RST

  debug("OLED: Initializing hardware on pin group ", udec(base_pin), "...", 13, 10)
  debug("OLED VAR addresses:", 13, 10)
  debug("  pixel_buffer: ", uhex_long(@pixel_buffer), " to ", uhex_long(@pixel_buffer + 32767), 13, 10)
  debug("  color_lut:    ", uhex_long(@color_lut), " to ", uhex_long(@color_lut + 8191), 13, 10)
  debug("  cell_origin:  ", uhex_long(@cell_origin_lut), " to ", uhex_long(@cell_origin_lut + 127), 13, 10)
  init_hardware()
  init_color_lut()
  init_cell_origin_lut()
  debug("OLED: Hardware ready", 13, 10)

  return TRUE

PUB start(oled_base_pin, oled_orientation) : success
'' Start the single-COG OLED driver with integrated FIFO management
'' @param oled_base_pin - base pin for OLED interface (typically 16)
'' @param oled_orientation - display orientation (0-3), use ORIENTATION_* constants
'' @returns TRUE if successful, FALSE if failed to start

  ' CRITICAL: Initialize cog_id first (defaults to 0, needs to be -1)
  if cog_id == 0
    cog_id := -1

  if cog_id >= 0
    return TRUE  ' Already running

  ' Initialize variables
  frame_count := 0
  orientation := oled_orientation   ' Set orientation BEFORE launching COG
  base_pin := oled_base_pin

  ' Calculate pin numbers from base
  pin_mosi := base_pin + OFFSET_MOSI
  pin_sclk := base_pin + OFFSET_SCLK
  pin_cs   := base_pin + OFFSET_CS
  pin_dc   := base_pin + OFFSET_DC
  pin_rst  := base_pin + OFFSET_RST

  debug("OLED Single-COG: Starting on pin group ", udec(base_pin), "...", 13, 10)

  ' Prepare stack for overflow detection
  stack_check.prepStackForCheck(@display_cog_stack, OLED_STACK_SIZE_LONGS)

  ' Start background COG - it will initialize its own hardware
  debug("OLED Single-COG: Launching display COG...", 13, 10)
  cog_id := cogspin(NEWCOG, display_loop(), @display_cog_stack)

  if cog_id < 0
    debug("OLED Single-COG: ERROR - COG failed to start!", 13, 10)
    return FALSE

  debug("OLED Single-COG: COG ", udec(cog_id), " started successfully", 13, 10)
  return TRUE

PUB stop()
'' Stop the OLED driver and terminate background cog operation
'' @returns nothing - stops all operations

  if cog_id >= 0 and cog_id <= 7
    cogstop(cog_id)
    cog_id := -1

PUB set_orientation(new_orientation)
'' Set display orientation for panel mounting flexibility
'' @param new_orientation - ORIENTATION_0 (0), ORIENTATION_90 (1), ORIENTATION_180 (2), or ORIENTATION_270 (3)
'' @returns nothing - updates display orientation

  if new_orientation >= 0 and new_orientation <= 3
    orientation := new_orientation

PUB get_frame_count() : count
'' Get total number of frames displayed
'' @returns frame count as LONG

  return frame_count

PUB get_timing_stats(last_us_ptr, min_us_ptr, max_us_ptr, avg_us_ptr) | avg_cycles
'' Get frame timing statistics
'' @param last_us_ptr - pointer to receive last frame time in microseconds
'' @param min_us_ptr - pointer to receive minimum frame time in microseconds
'' @param max_us_ptr - pointer to receive maximum frame time in microseconds
'' @param avg_us_ptr - pointer to receive average frame time in microseconds
'' @returns nothing - writes statistics to provided pointers

  if last_us_ptr
    LONG[last_us_ptr] := last_frame_cycles / 250
  if min_us_ptr
    LONG[min_us_ptr] := min_frame_cycles / 250
  if max_us_ptr
    LONG[max_us_ptr] := max_frame_cycles / 250
  if avg_us_ptr
    ' Note: Could add running average if needed, for now just return last
    LONG[avg_us_ptr] := last_frame_cycles / 250

PUB display_frame(framePtr) | row, col, sensor_idx, value, color, x, y, px, py, start_cycles, end_cycles, elapsed_cycles
'' Display a single frame to OLED (for testing - no FIFO, no background COG)
'' @param framePtr - pointer to 64-WORD sensor frame buffer
'' @returns nothing - renders frame and returns immediately
''
'' USE THIS FOR DRIVER TESTING - bypasses all FIFO/COG complexity

  ' Start timing measurement
  start_cycles := GETCT()

  ' Render 8x8 sensor grid to 128x128 display
  ' Each sensor cell = 16x16 pixels
  repeat row from 0 to 7
    repeat col from 0 to 7
      ' Calculate sensor index in frame buffer
      sensor_idx := (row * 8) + col

      ' Read sensor value (WORD)
      value := WORD[framePtr][sensor_idx]

      ' Check if this sensor is stuck (detected during calibration)
      ' Stuck sensors show as bright magenta to indicate non-operational
      if sensor.is_stuck(sensor_idx)
        color := STUCK_PIXEL_COLOR
      else
        ' Convert sensor value to color (uses unified formula internally)
        color := value_to_color(value, SENSOR_MIN, SENSOR_MAX)

      ' Calculate pixel position with orientation-specific coordinate transformation
      transform_coordinates(row, col, @x, @y)

      ' Set drawing window for this cell (16x16 pixels)
      set_window(x, y, x + CELL_WIDTH - 1, y + CELL_HEIGHT - 1)

      ' Fill cell with color (16x16 = 256 pixels)
      ' Keep CS/DC asserted for entire block (efficient streaming)
      PINLOW(pin_cs)      ' Select display
      PINHIGH(pin_dc)     ' Data mode

      ' Send pixels in row-major order (row by row, not column by column)
      ' Optimize: send color bytes with minimal waiting
      repeat 256  ' 16x16 pixels, unrolled loop
        spi_write_fast(color >> 8)
        spi_write_fast(color & $FF)

      ' Wait for final byte to complete before deasserting CS
      repeat until PINR(pin_sclk)
      PINHIGH(pin_cs)     ' Deselect after entire block

  ' End timing measurement and update statistics
  end_cycles := GETCT()
  elapsed_cycles := end_cycles - start_cycles
  last_frame_cycles := elapsed_cycles

  ' Update min/max statistics
  if total_frames_timed == 0
    min_frame_cycles := elapsed_cycles
    max_frame_cycles := elapsed_cycles
  else
    if elapsed_cycles < min_frame_cycles
      min_frame_cycles := elapsed_cycles
    if elapsed_cycles > max_frame_cycles
      max_frame_cycles := elapsed_cycles

  total_frames_timed++

  ' Report timing after 6th frame (for test programs that only display 6 frames)
  if total_frames_timed == 6
    ' Calculate timing in microseconds and frames per second
    ' At 250 MHz: 1 cycle = 4 ns, so cycles / 250 = microseconds
    debug("OLED: Frame timing summary (6 frames)", 13, 10)
    debug("  Last: ", udec(elapsed_cycles / 250), " us = ", udec(250_000_000 / elapsed_cycles), " fps", 13, 10)
    debug("  Min: ", udec(min_frame_cycles / 250), " us = ", udec(250_000_000 / min_frame_cycles), " fps", 13, 10)
    debug("  Max: ", udec(max_frame_cycles / 250), " us = ", udec(250_000_000 / max_frame_cycles), " fps", 13, 10)

PUB display_frame_fast(framePtr) | start_cycles, end_cycles, elapsed_cycles
'' Display a frame using optimized two-phase approach:
''   Phase 1: Pre-render sensor data to 128x128 pixel buffer (Spin2)
''   Phase 2: Stream entire buffer to display via PASM with events
'' @param framePtr - pointer to 64-WORD sensor frame buffer
'' @returns nothing - renders frame and returns immediately

  ' Start timing measurement
  start_cycles := GETCT()

  ' Phase 1: Pre-render sensor data to pixel buffer
  ' All color conversion and coordinate transformation happens here
  render_to_pixel_buffer(framePtr)

  ' DEBUG: Check pixel buffer contents after rendering
  if total_frames_timed == 0
    debug("FAST DEBUG: First pixel buffer check", 13, 10)
    debug("  Input sensor[0] = ", uhex(WORD[framePtr][0]), 13, 10)
    debug("  Color LUT[0] = ", uhex(WORD[@color_lut][0]), 13, 10)
    debug("  Color LUT[2048] = ", uhex(WORD[@color_lut][2048]), 13, 10)
    debug("  Color LUT[4095] = ", uhex(WORD[@color_lut][4095]), 13, 10)
    debug("  pixel_buffer[0] = ", uhex(WORD[@pixel_buffer][0]), 13, 10)
    debug("  pixel_buffer[1] = ", uhex(WORD[@pixel_buffer][1]), 13, 10)
    debug("  pixel_buffer[128] = ", uhex(WORD[@pixel_buffer][128]), 13, 10)

  ' Phase 2: Set full-screen window and stream all pixels via PASM
  ' Apply hardware offset (ROW_OFFSET compensates for SSD1351 RAM-to-pixel mapping)
  set_window(0, 0, WIDTH - 1, HEIGHT - 1)
  stream_pixel_buffer()

  ' End timing measurement and update statistics
  end_cycles := GETCT()
  elapsed_cycles := end_cycles - start_cycles
  last_frame_cycles := elapsed_cycles

  ' Update min/max statistics
  if total_frames_timed == 0
    min_frame_cycles := elapsed_cycles
    max_frame_cycles := elapsed_cycles
  else
    if elapsed_cycles < min_frame_cycles
      min_frame_cycles := elapsed_cycles
    if elapsed_cycles > max_frame_cycles
      max_frame_cycles := elapsed_cycles

  total_frames_timed++

PRI render_to_pixel_buffer(framePtr) | frame_ptr, lut_ptr, origin_lut_ptr, buf_ptr, cell_count, row_stride, sensor_val, color_val, cell_origin, row_count, row_ptr
'' Pre-render sensor frame to 128x128 pixel buffer with all transformations
'' @param framePtr - pointer to 64-WORD sensor frame buffer
'' @returns nothing - fills pixel_buffer with RGB565 data ready for streaming
''
'' PASM optimized: Uses pre-computed cell origin LUT and color LUT
'' Parameterized for future 32x32 support (change CELL_WIDTH/HEIGHT and LUT size)

  frame_ptr := framePtr
  lut_ptr := @color_lut
  origin_lut_ptr := @cell_origin_lut
  buf_ptr := @pixel_buffer
  cell_count := 64                    ' 8x8 grid = 64 cells
  row_stride := WIDTH * 2             ' Bytes per pixel buffer row (128 * 2)

  ' DIAGNOSTIC: Log buffer addresses on first frame to detect corruption
  if total_frames_timed == 0
    debug("OLED PASM addresses:", 13, 10)
    debug("  pixel_buffer: ", uhex_long(buf_ptr), " to ", uhex_long(buf_ptr + 32767), 13, 10)
    debug("  color_lut:    ", uhex_long(lut_ptr), " to ", uhex_long(lut_ptr + 8191), 13, 10)
    debug("  cell_origin:  ", uhex_long(origin_lut_ptr), " to ", uhex_long(origin_lut_ptr + 127), 13, 10)
    debug("  frame_ptr:    ", uhex_long(frame_ptr), 13, 10)

  ORG
        ' Register usage:
        ' ptra = sensor frame pointer (advances through 64 sensor values)
        ' ptrb = pixel buffer base (constant)
        ' pa = cell origin LUT pointer (advances through 64 entries)
        ' pb = cell counter (64 down to 0)

        mov     ptra, frame_ptr       ' Sensor frame base
        mov     ptrb, buf_ptr         ' Pixel buffer base
        mov     pa, origin_lut_ptr    ' Cell origin LUT base
        mov     pb, cell_count        ' 64 cells to process

.cell_loop
        ' Read sensor value (WORD) and scale to 12-bit LUT index
        ' Actual sensor range: SENSOR_MIN to SENSOR_MAX
        ' Scale: LUT_index = ((sensor_val - SENSOR_MIN) * 4095) / SENSOR_RANGE
        rdword  sensor_val, ptra++

        ' Subtract SENSOR_MIN to shift range to 0-based
        sub     sensor_val, ##SENSOR_MIN
        fges    sensor_val, #0        ' Clamp min to 0 if below SENSOR_MIN

        ' Scale: (val * 4095) / SENSOR_RANGE
        ' Use QMUL/QDIV for 32-bit precision
        setq    #0                    ' High 32 bits = 0 (fits in 9-bit)
        qmul    sensor_val, ##4095    ' sensor_val * 4095 (4095 > 511, needs ##)
        getqx   sensor_val            ' Get low 32 bits of result
        setq    #0                    ' High 32 bits for division = 0
        qdiv    sensor_val, ##SENSOR_RANGE   ' Divide by range
        getqx   sensor_val            ' Get quotient (LUT index 0-4095)

        ' Final clamp to valid LUT range (4095 > 511, needs ##)
        fle     sensor_val, ##4095    ' Clamp max to 4095
        fges    sensor_val, #0        ' Clamp min to 0 (0 fits in 9-bit #)

        ' Lookup color from LUT: color = lut_ptr[sensor_val]
        ' LUT is WORD array, so offset = sensor_val * 2
        shl     sensor_val, #1        ' sensor_val * 2 (byte offset)
        add     sensor_val, lut_ptr   ' Address of color entry
        rdword  color_val, sensor_val ' Read RGB565 color

        ' Read cell origin from pre-computed LUT (WORD offset into pixel buffer)
        rdword  cell_origin, pa
        add     pa, #2                ' Advance to next LUT entry

        ' Convert WORD offset to byte offset and add to buffer base
        shl     cell_origin, #1       ' WORD offset to byte offset
        add     cell_origin, ptrb     ' Absolute address of cell top-left

        ' Fill 16x16 pixel block (16 rows of 16 pixels each)
        ' Each pixel is 2 bytes (RGB565)
        mov     row_count, #16        ' 16 rows per cell

.row_loop
        ' Fill 16 pixels in this row with color_val
        ' Use SETQ + WRWORD for block write (8 WORDs at a time)
        mov     row_ptr, cell_origin

        ' Write 16 WORDs (pixels) - unrolled as 16 individual writes
        ' Could optimize further with REP but this is simpler
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr
        add     row_ptr, #2
        wrword  color_val, row_ptr

        ' Move to next row (add row stride to cell_origin)
        add     cell_origin, row_stride

        djnz    row_count, #.row_loop

        ' Next cell
        djnz    pb, #.cell_loop

  END

PRI get_cell_origin(row, col, px_ptr, py_ptr) | temp_row, temp_col, px, py
'' Calculate pixel buffer origin for a sensor cell based on orientation
'' @param row - sensor row (0-7)
'' @param col - sensor column (0-7)
'' @param px_ptr - pointer to receive x pixel coordinate
'' @param py_ptr - pointer to receive y pixel coordinate
'' @returns nothing - writes coordinates to pointers

  ' Stage 1: Transform from sensor layout to display-normal layout
  ' Sensor data appears rotated 90 left and horizontally mirrored
  temp_row := col
  temp_col := row

  ' Stage 2: Apply orientation-specific transformations
  case orientation
    ORIENTATION_0:
      ' Ribbon BOTTOM
      px := (7 - temp_col) * CELL_WIDTH
      py := temp_row * CELL_HEIGHT

    ORIENTATION_90:
      ' Ribbon LEFT (default)
      px := (7 - temp_col) * CELL_WIDTH
      py := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_180:
      ' Ribbon TOP
      px := (7 - temp_col) * CELL_WIDTH
      py := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_270:
      ' Ribbon RIGHT
      px := (7 - temp_col) * CELL_WIDTH
      py := temp_row * CELL_HEIGHT

  LONG[px_ptr] := px
  LONG[py_ptr] := py

PRI stream_pixel_buffer() | buf_ptr, pixel_count, mosi_pin, sclk_pin, cs_pin, dc_pin, pixel_val, byte_val
'' Stream entire pixel buffer to OLED via inline PASM with events
'' Uses waitse1 for efficient waiting instead of polling
'' Minimizes gap: akpin+wypin immediately after waitse1
'' @returns nothing - transmits all 32,768 bytes to display

  ' Copy pin numbers to local variables for PASM access
  buf_ptr := @pixel_buffer
  pixel_count := 16384
  mosi_pin := pin_mosi
  sclk_pin := pin_sclk
  cs_pin := pin_cs
  dc_pin := pin_dc

  ' Stream all pixels using inline PASM
  ORG
        ' Configure event for SCLK IN flag rise (P_PULSE clocks complete)
        ' Event encoding: %01 = positive edge, pin number in lower 6 bits
        mov     pa, sclk_pin
        or      pa, #%01_000000
        setse1  pa

        ' Assert CS and DC for data mode
        drvl    cs_pin                  ' CS low - select display
        drvh    dc_pin                  ' DC high - data mode

        ' Set up pixel counter and buffer pointer
        mov     ptra, buf_ptr
        mov     pb, pixel_count

.pixel_loop
        ' Read next RGB565 pixel from buffer
        rdword  pixel_val, ptra++

        ' === Prepare and send high byte ===
        mov     byte_val, pixel_val
        shr     byte_val, #8
        shl     byte_val, #24
        rev     byte_val
        wypin   byte_val, mosi_pin
        akpin   sclk_pin
        wypin   #8, sclk_pin
        waitse1

        ' === Prepare and send low byte ===
        ' Minimize gap: start next transfer IMMEDIATELY after waitse1
        mov     byte_val, pixel_val
        and     byte_val, #$FF
        shl     byte_val, #24
        rev     byte_val
        wypin   byte_val, mosi_pin
        akpin   sclk_pin
        wypin   #8, sclk_pin
        waitse1

        ' Loop until all pixels sent
        djnz    pb, #.pixel_loop

        ' Deassert CS
        drvh    cs_pin                  ' CS high - deselect display

  END

PRI init_hardware() | clk_period, temp, i
'' Initialize OLED hardware (GPIO pins, Smart Pins, display controller)
'' @returns nothing - performs hardware setup

  debug("OLED Single-COG: Initializing hardware...", 13, 10)

  ' Configure GPIO pins (CS, DC, RST)
  PINHIGH(pin_cs)    ' CS high (deselected)
  PINLOW(pin_dc)     ' DC low (default to command mode)
  PINHIGH(pin_rst)   ' RST high (not in reset)

  ' Calculate clock period for desired SPI frequency
  clk_period := 2 #> (CLKFREQ / SPI_FREQ) <# $FFFF

  debug("  Clock period: ", udec(clk_period), " ticks for ", udec(SPI_FREQ), " Hz", 13, 10)

  ' Configure SCLK as pulse mode for clock generation (copied from working driver)
  PINSTART(pin_sclk, P_OE | P_PULSE, clk_period | (clk_period >> 1) << 16, 0)

  ' Configure MOSI as Sync Serial TX mode (copied from working driver)
  ' Add clock pin offset in bits 24-26
  PINSTART(pin_mosi, P_OE | P_SYNC_TX | ((pin_sclk - pin_mosi) & %111) << 24, %1_00000 | 7, 0)


  ' Hardware reset sequence
  debug("  Performing hardware reset...", 13, 10)
  PINLOW(pin_rst)
  WAITMS(10)
  PINHIGH(pin_rst)
  WAITMS(10)

  ' Initialize display controller
  debug("  Initializing SSD1351 controller...", 13, 10)
  init_display()

  debug("  Hardware initialization complete", 13, 10)

PRI init_color_lut() | i, sensor_val, r, g, b, color, start_ms, corruption_idx, intensity, linear
'' Build color lookup table mapping 12-bit LUT indices to RGB565 colors
'' LUT index maps to full ADC range: index 0 = ADC 0, index 4095 = ADC 65535
'' Uses perceptually uniform gradient with gamma correction
'' Color gradient: Red (negative) -> Dark Gray (neutral) -> Green (positive)
'' Matches HDMI color scheme for consistent display
''
'' FIX (2025-12-26): Removed gray_fade to eliminate banding artifact.
'' See DOCs/Visualization-Theory-of-Operations.md for details.

  debug("  Building color LUT (4096 entries, gamma-corrected)...", 13, 10)
  debug("  color_lut addr=", uhex_long(@color_lut), " size=", udec(4096*2), " bytes", 13, 10)
  debug("  Baseline at LUT index: ", udec((SENSOR_MID * 4095) / SENSOR_RANGE), 13, 10)
  start_ms := getms()

  repeat i from 0 to 4095
    ' WATCHPOINT: Check FIFO integrity every 500 iterations
    if (i // 500) == 0
      corruption_idx := fifo.checkFreeListIntegrity()
      if corruption_idx >= 0
        debug("*** OLED LUT: FIFO CORRUPT at i=", udec(i), " freeList[", udec(corruption_idx), "] ***", 13, 10)

    ' Convert LUT index back to sensor value (0-65535)
    ' index 0 = sensor 0, index 4095 = sensor 65535
    sensor_val := (i * SENSOR_MAX) / 4095

    ' Apply perceptually uniform color formula with gamma correction
    ' Uses single intensity calculation (no gray_fade) to prevent banding
    ' Gamma ~2.0 approximation: gamma = (linear * linear) / 255
    if sensor_val < SENSOR_MID
      ' Negative field: Red increases from gray background
      linear := ((SENSOR_MID - sensor_val) * 255) / NEGATIVE_RANGE
      intensity := (linear * linear) / 255  ' Gamma correction ~2.0
      r := GRAY_BASE + intensity            ' Red increases from gray
      g := GRAY_BASE
      b := GRAY_BASE
    else
      ' Positive field: Green increases from gray background
      linear := ((sensor_val - SENSOR_MID) * 255) / POSITIVE_RANGE
      intensity := (linear * linear) / 255  ' Gamma correction ~2.0
      r := GRAY_BASE
      g := GRAY_BASE + intensity            ' Green increases from gray
      b := GRAY_BASE

    ' Clamp values to valid range (shouldn't be needed but safety)
    r := 0 #> r <# 255
    g := 0 #> g <# 255
    b := 0 #> b <# 255

    ' Convert 8-bit RGB to 5-6-5 BGR565 format (SSD1351 expects BGR)
    color := ((b >> 3) << 11) | ((g >> 2) << 5) | (r >> 3)
    color_lut[i] := color

  debug("  Color LUT ready (", udec(getms() - start_ms), " ms)", 13, 10)

PRI init_cell_origin_lut() | row, col, sensor_idx, px, py, pixel_offset
'' Build cell origin lookup table for fast PASM rendering
'' Pre-computes pixel buffer offset for each sensor cell's top-left corner
'' This allows PASM render to skip orientation math per-frame

  debug("  Building cell origin LUT (64 entries)...", 13, 10)

  repeat row from 0 to 7
    repeat col from 0 to 7
      sensor_idx := (row * 8) + col

      ' Calculate pixel coordinates using existing orientation logic
      get_cell_origin(row, col, @px, @py)

      ' Convert to pixel buffer WORD offset
      pixel_offset := (py * WIDTH) + px
      cell_origin_lut[sensor_idx] := pixel_offset

  debug("  Cell origin LUT ready", 13, 10)

PRI init_display()
'' Initialize SSD1351 OLED controller with optimized settings
'' @returns nothing - sends initialization command sequence

  debug("  init_display: Starting command sequence...", 13, 10)

  ' Command lock - unlock normal commands
  debug("  init_display: CMD_COMMAND_LOCK...", 13, 10)
  send_command(CMD_COMMAND_LOCK)
  send_data($12)
  debug("  init_display: CMD_COMMAND_LOCK done", 13, 10)

  ' Display off during configuration
  send_command(CMD_DISPLAY_OFF)

  ' Clock divider - Fosc=1, divider=1 (fastest)
  send_command(CMD_CLOCKDIV)
  send_data($F1)

  ' MUX ratio - 128 rows
  send_command(CMD_MUX_RATIO)
  send_data($7F)

  ' Set remap and color depth based on orientation
  send_command(CMD_SET_REMAP)
  send_data(BYTE[@remap_values][orientation])
  send_data($00)

  ' Start line
  send_command(CMD_START_LINE)
  send_data($00)

  ' Display offset
  send_command(CMD_DISPLAY_OFFSET)
  send_data($00)

  ' Set GPIO
  send_command(CMD_SET_GPIO)
  send_data($00)

  ' Function selection
  send_command(CMD_FUNCTION_SEL)
  send_data($01)

  ' Precharge period
  send_command(CMD_PRECHARGE)
  send_data($32)

  ' VCOMH voltage
  send_command(CMD_VCOMH)
  send_data($05)

  ' Normal display mode
  send_command(CMD_NORMAL_DISPLAY)

  ' Contrast settings (R, G, B)
  send_command(CMD_CONTRAST)
  send_data($C8)  ' Color A (Red)
  send_data($80)  ' Color B (Green)
  send_data($C8)  ' Color C (Blue)

  ' Master contrast
  send_command(CMD_MASTER_CONTRAST)
  send_data($0F)

  ' Linear grayscale LUT
  send_command(CMD_LINEAR_LUT)

  ' Precharge voltage
  send_command(CMD_PRECHARGE_V)
  send_data($17)

  ' Second precharge period
  send_command(CMD_PRECHARGE2)
  send_data($01)

  ' VSL
  send_command(CMD_SET_VSL)
  send_data($A0)
  send_data($B5)
  send_data($55)

  ' Display enhancement
  send_command(CMD_ENHANCEDISPLAY)
  send_data($A4)
  send_data($00)
  send_data($00)

  ' Display ON
  send_command(CMD_DISPLAY_ON)
  debug("  init_display: Display ON, waiting 10ms...", 13, 10)

  WAITMS(10)  ' Reduced from 100ms - SSD1351 only needs a few ms
  debug("  init_display: Complete", 13, 10)

PRI send_command(cmd)
'' Send command byte to OLED controller (COPIED FROM WORKING DRIVER)
'' @param cmd - command byte

  PINLOW(pin_cs)   ' Select display
  PINLOW(pin_dc)   ' Command mode
  spi_write(cmd)
  PINHIGH(pin_cs)  ' Deselect after command

PRI send_data(data)
'' Send data byte to OLED controller (COPIED FROM WORKING DRIVER)
'' @param data - data byte

  PINLOW(pin_cs)   ' Select display
  PINHIGH(pin_dc)  ' Data mode
  spi_write(data)
  PINHIGH(pin_cs)  ' Deselect after data

PRI spi_write(value) | reversed
'' Send byte via Smart Pin SPI using inline REV instruction
'' @param value - byte to send

  ' Bit-reverse the value inline (replaces LUT lookup)
  reversed := (value & $FF) << 24
  reversed REV= 31

  ' Load bit-reversed value
  WYPIN(pin_mosi, reversed)

  ' Trigger 8 clock pulses
  WYPIN(pin_sclk, 8)

  ' Wait for transmission complete
  repeat until PINR(pin_sclk)

PRI spi_write_fast(value) | reversed
'' Send byte via Smart Pin SPI - OPTIMIZED (no wait between consecutive bytes)
'' @param value - byte to send
'' NOTE: Caller must wait for final transmission to complete

  ' Wait for previous transmission to complete before loading new data
  repeat until PINR(pin_sclk)

  ' Bit-reverse the value inline (replaces LUT lookup)
  reversed := (value & $FF) << 24
  reversed REV= 31

  ' Load bit-reversed value
  WYPIN(pin_mosi, reversed)

  ' Trigger 8 clock pulses
  WYPIN(pin_sclk, 8)

  ' Return immediately without waiting - allows pipelining

PRI set_window(x1, y1, x2, y2)
'' Set active drawing window on OLED display
'' @param x1 - starting column (0-127)
'' @param y1 - starting row (0-127)
'' @param x2 - ending column (0-127)
'' @param y2 - ending row (0-127)
'' @returns nothing - configures drawing area

  send_command(CMD_SET_COLUMN)
  send_data(x1 + COLUMN_OFFSET)
  send_data(x2 + COLUMN_OFFSET)

  send_command(CMD_SET_ROW)
  send_data(y1 + ROW_OFFSET)
  send_data(y2 + ROW_OFFSET)

  send_command(CMD_WRITE_RAM)

PRI set_window_raw(x1, y1, x2, y2)
'' Set active drawing window without applying offsets
'' Used for full-screen streaming where pixel buffer is pre-rendered in display order
'' @param x1 - starting column (0-127)
'' @param y1 - starting row (0-127)
'' @param x2 - ending column (0-127)
'' @param y2 - ending row (0-127)

  send_command(CMD_SET_COLUMN)
  send_data(x1)
  send_data(x2)

  send_command(CMD_SET_ROW)
  send_data(y1)
  send_data(y2)

  send_command(CMD_WRITE_RAM)

PRI transform_coordinates(row, col, x_ptr, y_ptr) | x, y, temp_row, temp_col
'' Transform buffer coordinates (row, col) to display coordinates (x, y) based on orientation
'' @param row - buffer row (0-7)
'' @param col - buffer column (0-7)
'' @param x_ptr - pointer to x coordinate output
'' @param y_ptr - pointer to y coordinate output
'' @returns nothing - writes x, y to pointers
''
'' Two-stage transformation:
''   Stage 1: Sensor layout to display layout (rotate 90° right + un-mirror)
''   Stage 2: Orientation-specific positioning based on ribbon location

  ' STAGE 1: Transform from sensor data layout to display-normal layout
  ' Sensor data appears rotated 90° left and horizontally mirrored relative to display
  ' So we rotate 90° right and un-mirror to normalize
  temp_row := col          ' Rotate 90° right: old col becomes new row (no inversion)
  temp_col := row          ' Rotate 90° right: old row becomes new col (no inversion)

  ' STAGE 2: Apply orientation-specific transformations
  ' These position the normalized data correctly based on ribbon location
  case orientation
    ORIENTATION_0:
      ' Ribbon BOTTOM: Away from ribbon, left side
      x := (7 - temp_col) * CELL_WIDTH
      y := temp_row * CELL_HEIGHT

    ORIENTATION_90:
      ' Ribbon LEFT: Next to ribbon, left side
      x := (7 - temp_col) * CELL_WIDTH
      y := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_180:
      ' Ribbon TOP: Next to ribbon, right side
      x := (7 - temp_col) * CELL_WIDTH
      y := (7 - temp_row) * CELL_HEIGHT

    ORIENTATION_270:
      ' Ribbon RIGHT: Away from ribbon, right side
      x := (7 - temp_col) * CELL_WIDTH
      y := temp_row * CELL_HEIGHT

  ' Write results to output pointers
  LONG[x_ptr] := x
  LONG[y_ptr] := y

PRI value_to_color(value, min_val, max_val) : color | r, g, b, intensity, linear
'' Convert sensor value to RGB565 color using perceptually uniform gradient
'' @param value - sensor value (0-65535)
'' @param min_val - minimum expected value (unused, kept for API compatibility)
'' @param max_val - maximum expected value (unused, kept for API compatibility)
'' @returns RGB565 color (16-bit)
''
'' Uses gamma-corrected intensity for smooth perceptual gradient.
'' See DOCs/Visualization-Theory-of-Operations.md for details.
''
'' FIX (2025-12-26): Removed gray_fade to eliminate banding artifact.

  ' Clamp to valid ADC range
  value := SENSOR_MIN #> value <# SENSOR_MAX

  ' Apply perceptually uniform color formula with gamma correction
  if value < SENSOR_MID
    ' Negative field: Red increases from gray background
    linear := ((SENSOR_MID - value) * 255) / NEGATIVE_RANGE
    intensity := (linear * linear) / 255  ' Gamma correction ~2.0
    r := GRAY_BASE + intensity            ' Red increases from gray
    g := GRAY_BASE
    b := GRAY_BASE
  else
    ' Positive field: Green increases from gray background
    linear := ((value - SENSOR_MID) * 255) / POSITIVE_RANGE
    intensity := (linear * linear) / 255  ' Gamma correction ~2.0
    r := GRAY_BASE
    g := GRAY_BASE + intensity            ' Green increases from gray
    b := GRAY_BASE

  ' Clamp to valid range
  r := 0 #> r <# 255
  g := 0 #> g <# 255
  b := 0 #> b <# 255

  ' Convert 8-bit RGB to 5-6-5 BGR565 format (SSD1351 expects BGR, not RGB)
  color := ((b >> 3) << 11) | ((g >> 2) << 5) | (r >> 3)

PRI display_loop() | framePtr
'' Background COG display loop - dequeues frames and renders to OLED
'' Runs in dedicated COG, integrates FIFO management and display rendering

  ' Background COG initializes its own hardware (owns its pins)
  debug("OLED Single-COG: Initializing hardware in background COG...", 13, 10)

  ' CRITICAL: Show stack address to diagnose memory corruption
  debug("OLED STACK: ", uhex_long(@display_cog_stack), " to ", uhex_long(@display_cog_stack + (OLED_STACK_SIZE_LONGS * 4) - 1), 13, 10)

  ' Show VAR buffer addresses to verify memory layout
  debug("OLED VAR addresses:", 13, 10)
  debug("  pixel_buffer: ", uhex_long(@pixel_buffer), " to ", uhex_long(@pixel_buffer + 32767), 13, 10)
  debug("  color_lut:    ", uhex_long(@color_lut), " to ", uhex_long(@color_lut + 8191), 13, 10)
  debug("  cell_origin:  ", uhex_long(@cell_origin_lut), " to ", uhex_long(@cell_origin_lut + 127), 13, 10)

  ' Check stack BEFORE init (baseline)
  debug("OLED: Stack check BEFORE init_hardware...", 13, 10)
  stack_check.checkStack(@display_cog_stack, OLED_STACK_SIZE_LONGS)

  init_hardware()

  ' Check stack AFTER init_hardware
  debug("OLED: Stack check AFTER init_hardware...", 13, 10)
  stack_check.checkStack(@display_cog_stack, OLED_STACK_SIZE_LONGS)

  init_color_lut()

  ' Check stack AFTER init_color_lut
  debug("OLED: Stack check AFTER init_color_lut...", 13, 10)
  stack_check.checkStack(@display_cog_stack, OLED_STACK_SIZE_LONGS)

  init_cell_origin_lut()

  ' Check stack AFTER init_cell_origin_lut
  debug("OLED: Stack check AFTER init_cell_origin_lut...", 13, 10)
  stack_check.checkStack(@display_cog_stack, OLED_STACK_SIZE_LONGS)

  debug("OLED Single-COG: Display loop started", 13, 10)

  repeat
    ' Check for stack overflow (halts with debug message if detected)
    stack_check.checkStack(@display_cog_stack, OLED_STACK_SIZE_LONGS)

    ' Dequeue frame from OLED FIFO (blocking)
    framePtr := fifo.dequeue(fifo.FIFO_OLED)

    if framePtr == 0
      ' No frame available, wait and retry
      WAITMS(5)
      next

    ' Display frame using cell-by-cell method (display_frame_fast has offset issues)
    display_frame(framePtr)

    ' Release frame back to pool
    fifo.releaseFrame(framePtr)

    ' Increment frame count
    frame_count++

PRI send_pixel_data(color)
'' Send RGB565 pixel data (2 bytes) to OLED via SPI (USES WORKING SPI CODE)
'' @param color - RGB565 color value (16-bit)
'' @returns nothing - transmits high byte then low byte

  ' Keep CS low for both bytes (efficient multi-byte transaction)
  PINLOW(pin_cs)      ' Select display
  PINHIGH(pin_dc)     ' Data mode

  ' Send high byte
  spi_write(color >> 8)

  ' Send low byte
  spi_write(color & $FF)

  PINHIGH(pin_cs)     ' Deselect after both bytes

CON { license }
{{

 -------------------------------------------------------------------------------------------------
  MIT License

  Copyright (c) 2025 Iron Sheep Productions, LLC

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 =================================================================================================
}}
